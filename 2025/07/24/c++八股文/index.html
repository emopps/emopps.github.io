

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="emopps">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++八股文 C++面向对象的三大特性 封装：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。 继承：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修">
<meta property="og:type" content="article">
<meta property="og:title" content="c++八股文">
<meta property="og:url" content="https://emopps.github.io/2025/07/24/c++%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="emopps">
<meta property="og:description" content="C++八股文 C++面向对象的三大特性 封装：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。 继承：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://emopps.github.io/2025/07/24/c++%E5%85%AB%E8%82%A1%E6%96%87/image.png">
<meta property="article:published_time" content="2025-07-24T15:05:53.000Z">
<meta property="article:modified_time" content="2025-07-24T13:08:57.916Z">
<meta property="article:author" content="emopps">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://emopps.github.io/2025/07/24/c++%E5%85%AB%E8%82%A1%E6%96%87/image.png">
  
  
  
  <title>c++八股文 - emopps</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"emopps.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>emopps</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c++八股文"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-24 23:05" pubdate>
          2025年7月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          105 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">c++八股文</h1>
            
            
              <div class="markdown-body">
                
                <h1>C++八股文</h1>
<h2 id="C-面向对象的三大特性">C++面向对象的三大特性</h2>
<p><strong>封装</strong>：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。<br>
<strong>继承</strong>：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。<br>
<strong>多态</strong>：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。</p>
<ul>
<li>静态多态：函数重载</li>
<li>动态多态：通过虚函数重写</li>
</ul>
<h2 id="C-多态的实现">C++多态的实现</h2>
<p>C++的多态分为静态多态和动态多态。</p>
<p><strong>静态多态</strong>的实现原理是<strong>函数重载和模板函数</strong>(编译器确定)。</p>
<ul>
<li>函数重载指的是在同一个作用域内，可以定义多个函数，它们具有相同的名称但参数列表不同的情况。在调用这些函数时，编译器会根据函数调用时提供的参数类型和数量来确定调用哪个函数。模板函数是指在定义函数时使用了类型参数，让函数适用于多种不同的类型。编译器在编译时根据参数类型生成具体的函数实现。模板函数的实现是通过编译时的模板实例化来实现的。</li>
</ul>
<p><strong>动态多态</strong>指的是在<strong>运行时</strong>根据对象的实际类型确定要调用的函数。动态多态实现的方法是<strong>虚函数重写和抽象类</strong>。虚函数是指在基类中定义的函数可以被派生类重写的函数。通过将函数声明为虚函数，我们可以在运行时根据对象的实际类型来确定要调用的函数实现。在C++中，只要将函数声明为虚函数即可实现动态多态。抽象类是指包含至少一个纯虚函数的类，这个类不能被实例化，只能用作基类来派生出其他类。在C++中，可以通过将函数声明为纯虚函数来实现抽象类。其原理就是早绑定和晚绑定。早绑定即编译时确定调用函数的地址，晚绑定即类使用virtual函数时生成虚表存放虚函数的地址，类对象构造时进行初始化。</p>
<h2 id="C-指针和引用的区别？">C++指针和引用的区别？</h2>
<p>在 C++中，引用本身并不占用额外的内存空间。当你传递一个变量作为引用参数给函数时，函数内部会使用该引用来直接操作原始变量，而不是创建原始变量的副本。因此，使用引用可以避免不必要的数据复制，提高程序的效率。引用的内部实现通常是通过指针来完成的，因此在函数调用时，引用本身并不会在栈上分配额外的内存空间，只是会使用一个指针来指向原始变量的内存地址。总结起来，引用不占用函数栈内存，但会占用一个指针的大小。<br>
指针与引用的区别：</p>
<ul>
<li>指针本身是一个对象，允许进行赋值和拷贝等操作。</li>
<li>指针的生命周期内可以指向几个不同的对象，引用不可以。</li>
<li>指针不需要在定义时赋初值。<br>
需要注意的是，引用在底层实现上通常被编译器实现为指针，但是在使用时更类似于被引用的变量本身。引用在编译时会被转换为指针。引用在被使用的使用会占用4个字节大小的内存空间，也就是一个指针的大小</li>
</ul>
<h2 id="C-的构造函数能否定义为虚函数？">C++的构造函数能否定义为虚函数？</h2>
<p>不能。</p>
<ul>
<li>
<p>虚函数通过虚表实现多态，每个类内存有一个虚表，表内存放虚指针。这个虚指针是构造对象时被初始化的。</p>
</li>
<li>
<p><strong>虚函数的工作机制</strong>：虚函数通过虚函数表（vtable）来实现多态。每个包含虚函数的类都有一个虚函数表，其中存放了指向该类虚函数的指针。每个对象在创建时，会有一个指向其虚函数表的指针（vptr）。这个vptr是在对象构造期间被初始化的。从构造函数的<strong>调用时序</strong>看，在构造一个派生类对象时，首先调用基类的构造函数，然后依次调用派生类的构造函数。在基类构造函数执行期间，对象的类型是基类类型，而不是派生类类型。C++语言标准明确规定，构造函数不能是虚函数。如果你尝试在构造函数声明前加上virtual关键字，编译器会报错。</p>
</li>
</ul>
<h2 id="智能指针有没有了解？shared-ptr和unique-ptr讲一下">智能指针有没有了解？shared_ptr和unique_ptr讲一下</h2>
<p>智能指针的实现是利用了RAII的技术对普通指针进行封装，使得智能指针本质上是一个对象，却表现出一个指针的行为。智能指针的<strong>作用</strong>是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存，解决多次释放同一指针造成崩溃的问题。智能指针还可以把值语义转换成引用语义。</p>
<p>智能指针的内存问题：智能指针位于栈区域，它管理的对象是位于堆区域。堆区域是程序运行时内存动态分配的地方，智能指针指向堆上的对象，当不再需要这个对象时会自动释放内存。</p>
<ul>
<li>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁，因为shared_ptr的指向对象部分并不是线程安全的。</li>
<li>unique_ptr独占其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。与原始指针相比，unique_ptr由于其RAII的特性，使得在出现异常的情况下，动态资源仍然能得到释放。</li>
<li>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。C++11中被废弃。</li>
</ul>
<h2 id="对锁有没有了解，介绍一下？">对锁有没有了解，介绍一下？</h2>
<ul>
<li>mutex:最基本的互斥锁，不可重入</li>
<li>recursive_mutex：可重入互斥锁，允许同一线程多次加锁</li>
<li>timed_mutex：带超时功能的互斥锁，尝试获取锁一段时间，超时则返回。</li>
<li>recursive_timed_mutex：可重入且支持超时</li>
<li>shared_mutex：读写锁，支持两种访问模式，适用于读多写少的场景。</li>
<li>shared_timed_mutex：shared_mutex基础上增加了超时功能</li>
</ul>
<h2 id="move和forward的区别？">move和forward的区别？</h2>
<ul>
<li>move:将对象无条件转换为右值引用，启用移动语义.无论接受左值还是右值，都返回右值引用。实质是静态类型转换：static_cast&lt;T&amp;&amp;&gt;(t)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2 = std::<span class="hljs-built_in">move</span>(s1);  <span class="hljs-comment">// 移动构造，s1 变为空</span><br></code></pre></td></tr></table></figure>
<ul>
<li>forward:在模板中完美转发参数，保持原始值类别（左值/右值）。仅在模板中使用（通常是通用引用 T&amp;&amp;）。根据模板参数T的类型决定转发为左值还是右值.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Arg&gt;<br><span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(Arg&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(std::forward&lt;Arg&gt;(arg));  <span class="hljs-comment">// 保持 arg 的原始值类别</span><br>&#125;<br><br>std::string s = <span class="hljs-string">&quot;Test&quot;</span>;<br><span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">create</span>&lt;std::string&gt;(s);       <span class="hljs-comment">// 传递左值 → 调用拷贝构造</span><br><span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">create</span>&lt;std::string&gt;(<span class="hljs-string">&quot;Temp&quot;</span>);  <span class="hljs-comment">// 传递右值 → 调用移动构造</span><br></code></pre></td></tr></table></figure>
<h2 id="C-的栈容器的内部是什么样的，内存是否连续？">C++的栈容器的内部是什么样的，内存是否连续？</h2>
<p>C++的栈stack不是独立容器，是基于其他的序列容器的。默认是使用deque双端队列实现。</p>
<ul>
<li>deque内存连续，由多个固定大小内存块组成</li>
<li>vector：完全连续，是开辟了一大块大的内存块用于使用</li>
<li>list：非连续，双休链表节点分散存储</li>
</ul>
<h2 id="shared-ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？">shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？</h2>
<p>引用计数的<strong>核⼼原理</strong>：</p>
<ul>
<li>在shared_ptr的内部维护了⼀个计数器，来跟踪有多少个shared_ptr对象指向了某⼀个资源。当计数器的值减少到0的时候，shared_ptr就会调⽤delete(或者⽤户⾃定义的⽅法)来释放资源。</li>
</ul>
<p>引用计数器何时<strong>增加</strong>：</p>
<ul>
<li>新建⼀个shared_ptr并指向了⼀个资源时。</li>
<li>复制构造函数创建⼀个新的shared_ptr时。</li>
<li>⽤复制运算符将⼀个shared_ptr给另⼀个shared_ptr对象赋值时。</li>
</ul>
<p>引⽤计数器何时<strong>减少</strong>：</p>
<ul>
<li>当⼀个shared_ptr对象被销毁时，⽐如局部变量离开作⽤域，或者类成员变量析构时。2.</li>
<li>当⼀个shared_ptr对象不再指向⼀个资源时，例如通过reset⽅法或者赋值运算符指向另⼀个资源时。</li>
</ul>
<h2 id="讲一下循环引用如何发生的，以及如何解决？">讲一下循环引用如何发生的，以及如何解决？</h2>
<p>在两个或多个对象相互引用，或者⼀些复杂的数据结构，如图，双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法被释放掉。这个时候就需要使用weak_ptr来打破循环引⽤。因为使⽤weak_ptr指向某⼀个资源时，它不会增加这个资源的引⽤计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeB</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 使用 shared_ptr 会导致循环引用</span><br>    std::shared_ptr&lt;NodeB&gt; b_ptr;<br>    <span class="hljs-comment">// 解决方案：使用 weak_ptr 替代</span><br>    <span class="hljs-comment">// std::weak_ptr&lt;NodeB&gt; b_ptr;</span><br>    <br>    ~<span class="hljs-built_in">NodeA</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeA 销毁\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;NodeA&gt; a_ptr;<br>    ~<span class="hljs-built_in">NodeB</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeB 销毁\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建两个节点</span><br>    <span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">make_shared</span>&lt;NodeA&gt;();<br>    <span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">make_shared</span>&lt;NodeB&gt;();<br>    <br>    <span class="hljs-comment">// 建立相互引用</span><br>    a-&gt;b_ptr = b;  <span class="hljs-comment">// shared_ptr 版本会导致循环引用</span><br>    b-&gt;a_ptr = a;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a 引用计数: &quot;</span> &lt;&lt; a.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b 引用计数: &quot;</span> &lt;&lt; b.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-comment">// main 结束时，a 和 b 应该被销毁...</span><br>    <span class="hljs-comment">// 但如果使用 shared_ptr，由于循环引用，引用计数不会归零</span><br>    <span class="hljs-comment">// 只有使用 weak_ptr 才能正确销毁</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="shared-ptr是线程安全的吗？多线程中使用智能指针要注意什么？">shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？</h2>
<ul>
<li>多线程代码操作的是同一个shared_ptr的对象是线程不安全的。</li>
<li>多线程代码操作的不是同一个shared_ptr的对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。</li>
</ul>
<h2 id="何时用shared-ptr，何时用weak-ptr">何时用shared_ptr，何时用weak_ptr?</h2>
<p>在我们需要对引用的资源进行指针之间的共享的时候，我们通常会使用shared_ptr。在使用shared_ptr，weak_ptr会作为一个配合它使用的辅助指针来使用，使用到weak_ptr的场景通常有两种。</p>
<ul>
<li>在使用shared_ptr时，我们要解决循环引用的问题，这时我们要用weak_ptr来打破循环引用的问题，避免资源无法被释放。</li>
<li>当我们需要使用一个共享的内存，但是从业务逻辑上来讲，这个持有不应该对这个资源的生命周期有影响，这时我们也应该使用weak_ptr而不是用shared_ptr。</li>
</ul>
<h2 id="介绍⼀下static和const">介绍⼀下static和const</h2>
<p><strong>Const</strong>:</p>
<ul>
<li>基本概念：Const允许我们指定⼀个语义约束, 告诉编译器某个对象不应该被改变。而编译器会强制帮助我们实施这⼀项约束。如果我们认定某个值不能被改变，那么我们就应该使用const，来让编译器帮助我们来保证这个条件不被违反。</li>
<li>适用场景：const可以修饰很多内容。对于普通对象，可以修饰局部的，全局的，或者区块作⽤域中的普通对象；对于函数，可以修饰函数的返回值，函数的参数；对于指针，可以修饰指针本身（指针常量），也可以修饰指针所指的对象（常量指针）；对于类，可以修饰类的成员变量，也可以修饰类的成员函数。</li>
</ul>
<p><strong>Static</strong>:</p>
<p>C++中的static关键字具有多种用途。可以声明静态成员变量，静态成员函数，静态局部变量，静态全局变量。</p>
<ul>
<li>静态成员变量和函数：是类的所有对象共享的成员变量。它们不属于任何特定的对象，而属于类本身。静态成员变量在类的所有对象之间只有⼀个实例。</li>
<li>静态成员函数：静态成员函数是不依赖于类的任何特定对象的成员数据。它们可以在没有类的对象的情况下调用。</li>
<li>静态局部变量：静态局部变量是在函数内部声明的静态变量，它与普通局部函数的变量不同，静态局部变量在程序运⾏期间只初始化⼀次，即使函数被多次调用。</li>
<li>静态全局变量：静态全局变量是全局作用域内声明的静态变量。它们的可用性仅限于定义它们的源文件，意味着它们不能在其它源文件中访问，有助于封装和避免命名冲突。</li>
</ul>
<h2 id="new和malloc的区别">new和malloc的区别</h2>
<ul>
<li>性质不同：new是⼀个c++中特有的操作符，⽽malloc是c语⾔中的内存分配函数。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。</li>
<li>内存分配⽅式不同：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的构造函数来初始化对象。</li>
<li>使⽤语法不同：malloc使⽤时需要指定分配内存的⼤⼩，如malloc(sizeof(int)), 但new不⽤，使⽤更加简洁，如：new int</li>
<li>返回类型：malloc返回void*类型指针，需要强制转换成其它指定类型，⽽new直接返回响应的数据类型的指针，无需类型转换。</li>
<li>错误处理：内存分配失败后，malloc返回null, ⽽new会抛出std::bad_malloc异常。</li>
<li>配对操作：malloc分配内存使用free释放，⽽new分配内存要使用delete释放。</li>
</ul>
<h2 id="什么是左值？什么是右值？">什么是左值？什么是右值？</h2>
<ul>
<li>左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址。</li>
<li>右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址。</li>
</ul>
<h2 id="C和C-的区别？">C和C++的区别？</h2>
<p>C++是C加上⼀些⾯向对象的特性。最初C++只是C加上⼀些⾯向对象的特性，但随着语⾔的发展，C++⽀持了更多观念和特性，变得⽐C语⾔更具有弹性和灵活性。现在的C++相⽐C，是⼀个语⾔联邦，它包含了C语⾔，但具有更多特性。</p>
<ul>
<li>.C++以C为基础，包含了C语⾔部分。区块，语句，预处理器，内置数据类型，数组，指针等特性都是来⾃于C。</li>
<li>C++包含了⾯向对象的特性，⽐如封装，继承，多态，virtual函数的特性。</li>
<li>C++包含了泛型编程的部分。</li>
<li>C++包含了STL部分。<br>
总之，C++是在C语⾔基础上，包含了其它特性⽽发展⽽来的，相⽐C语⾔来说更加灵活和复杂。</li>
</ul>
<h2 id="前置-返回的是左值还是右值，后置-呢？字符串字面量呢">前置++返回的是左值还是右值，后置++呢？字符串字面量呢?</h2>
<ul>
<li>前置++的实现是直接对传入的对象自增，然后将此对象返回，因此它返回的是⼀个具有名称的稳定的<strong>左值</strong>。</li>
<li>后置++的实现是创建⼀个临时对象，然后对传入的对象自增，然后返回的是⼀个这个临时的对象，因此它返回的是⼀个<strong>右值</strong>。</li>
<li>字符串变量也是⼀个左值，因为它会将字符串变量存储到程序的数据段中，程序加载时会为它开辟内存空间，所以我们可以⽤&amp;取地址，所以是左值。</li>
</ul>
<h2 id="右值引用是如何提⾼性能的？">右值引用是如何提⾼性能的？</h2>
<p>右值引⽤主要是通过避免不必要的拷贝操作来提高代码的性能的。</p>
<h2 id="介绍⼀下RVO？">介绍⼀下RVO？</h2>
<p>RVO（ReturnValueOptimization）是⼀种编译器优化技术，用于消除不必要的临时对象拷贝，提高代码的性能。RVO主要针对函数返回局部对象的情况，通过优化，可以避免创建临时对象并执行拷贝构造函数。<br>
RVO的<strong>基本思想</strong>是：在函数调用栈上直接构造返回值，而不是先构造⼀个局部对象，然后再拷贝到调用者的栈空间。这样可以减少临时对象的创建和销毁，提高代码的运行效率。</p>
<h2 id="如果一个class的this指针被删除后强行访问会有什么影响？">如果一个class的this指针被删除后强行访问会有什么影响？</h2>
<p>会出现崩溃或者输出乱码值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">42</span>; <span class="hljs-comment">// 假设有一个成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 销毁对象</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    C *obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">C</span>();<br>    obj-&gt;<span class="hljs-built_in">destroy</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;强行访问 obj-&gt;data: &quot;</span> &lt;&lt; obj-&gt;data &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：<br>
<img src="image.png" srcset="/img/loading.gif" lazyload alt="alt text"></p>
<h2 id="volatile关键字的作用？">volatile关键字的作用？</h2>
<p>volatile关键字的作用就是防止编译器优化，编译器每次读变量的值都从内存直接读取最新值且写操作时直接写入内存。该关键字不保证线程安全。如果目的是实现原子操作推荐atomic。<br>
适用场景：</p>
<ul>
<li>硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）</li>
<li>中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值</li>
<li>多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全</li>
<li>防止空循环被优化</li>
</ul>
<h2 id="C-函数封装器为什么优于函数指针？">C++函数封装器为什么优于函数指针？</h2>
<p>函数封装器的<strong>优点</strong>：</p>
<ul>
<li>函数封装器兼容函数指针，lambda表达式和仿函数，代码更加简洁、清晰且利于拓展。</li>
<li>函数封装器类型安全，有严格的类型检查。</li>
<li>与现代C++特性的深度集成</li>
<li>面向对象支持</li>
</ul>
<h2 id="strcpy的缺点是什么？">strcpy的缺点是什么？</h2>
<ul>
<li>strcpy会造成缓冲区溢出并导致不确定的问题。</li>
<li>strcpy会导致软件漏洞容易被利用。轻则导致程序崩溃，重则导致黑客找到存储器上返回地址的值，替换为恶意程序。</li>
</ul>
<h2 id="class和struct的区别？">class和struct的区别？</h2>
<ul>
<li>class的默认成员和继承都是private的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。</li>
<li>struct默认是public的，如果是要给外部提供一些所需的数据可以使用struct。</li>
</ul>
<h2 id="C-中switch和if-else的区别在哪里？">C++中switch和if else的区别在哪里？</h2>
<ul>
<li>switch只支持整数和枚举类型，如果是仅仅使用整数和枚举类型的逻辑判断，使用switch的性能更佳。编译器会生成一个跳转表给switch语句。考虑代码可读性推荐使用。</li>
<li>if else可以判断所有的逻辑类型。if else使用遍历的方法。理论上性能会差一点，但是编译器优化后，只要分支不超过100个，switch的性能和if else性能接近。</li>
</ul>
<h2 id="C-inline内联的作用？">C++ inline内联的作用？</h2>
<ul>
<li>inline内联即直接把该部分的代码复制到调用处，这样就不会有代码调用的call的开销，提高代码的性能，但是会导致代码膨胀，降低编译速度。C++17开始容许多次定义，即2个不同的C++文件中的同名inline内联函数可以实现不同的功能，类似static，对别的C++文件屏蔽该函数。如果在同一个C++文件中设置2个同名内联函数，在链接阶段会出现一个情况，即随机挑选一个函数链接上。(但是我试了一下使用gcc编译这种情况是没办法编译成功的)</li>
</ul>
<h2 id="虚函数和纯虚函数的区别？">虚函数和纯虚函数的区别？</h2>
<ul>
<li>虚函数是实现C++运行时多态的核心机制，通过virtual关键字声明，当通过基类指针或引用调用虚函数时，会根据对象的实际类型动态绑定到正确的函数实现。虚函数可以有默认实现，派生类可以选择性重写，包含虚函数的类可以实例化。</li>
<li>纯虚函数通过在虚函数声明后加=0定义，没有默认实现，强制派生类必须重写。包含纯虚函数的类称为抽象类，不能实例化，纯虚函数用于定义接口规范，确保所有派生类都有该功能。<br>
代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>usingnamespacestd;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 虚函数，有默认实现</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal sound&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 重写虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Woof!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Animal* animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>    animal-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: Woof!</span><br>    <span class="hljs-keyword">delete</span> animal;<br>    return0;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>usingnamespacestd;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数，无实现</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> :<span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 必须实现纯虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Drawing a circle&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Shape shape;  // 错误: 不能实例化抽象类</span><br>    Shape* shape = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    shape-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 输出: Drawing a circle</span><br>    <span class="hljs-keyword">delete</span> shape;<br>    return0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="怎么解决菱形继承？">怎么解决菱形继承？</h2>
<p>C++具备多重继承，导致会出现菱形继承的问题。<br>
一个子类继承自多个父类，多个父类本身也可以继承自同一个基类。<br>
菱形继承会导致二义性，存储空间浪费的问题。<br>
解决方法：</p>
<ul>
<li>虚继承：子类只继承一次父类的父类。在中间基类继承父共同基类时加上virtual关键词。其实现原理就是<strong>依靠虚基类表</strong>，编译器为每个虚继承的类生成一个虚基类指针，指向这个虚基类表。虚基类表存储偏移量，用于在运行时定位共享基类成员的位置对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MostDerived</span> : <span class="hljs-keyword">public</span> Derived1, <span class="hljs-keyword">public</span> Derived2 &#123;&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="override和final关键字的作用？">override和final关键字的作用？</h2>
<p>解决不能阻止某个虚函数进一步重写的问题。<br>
override:显式标记派生类中的函数是对基类虚函数的覆盖（重写），并强制编译器检查函数签名是否完全匹配。核心机制是签名检查(编译器验证派生类函数的签名是否与基类虚函数一致）和避免假重写。<br>
final:禁止类被继承或虚函数被进一步重写，锁定设计意图。修饰类则类不可被继承。修饰虚函数则虚函数在派生类中不可再被重写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 基类虚函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// ✅ 正确覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-comment">// ❌ 编译错误：参数类型不匹配</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// ❌ 编译错误：foo是final的[3,9](@ref)  </span><br>&#125;;  <br></code></pre></td></tr></table></figure>
<h2 id="C-类型推导的作用和用法？">C++类型推导的作用和用法？</h2>
<p>C++作为一种强类型语言，类型匹配比较麻烦，所以借助编译器来处理类型推导比较好，提升编码效率。<br>
<strong>auto</strong>：用于变量的类型的推导，初始化一个值然后去推导变量的类型。如果是使用auto定义多个变量，多个变量必须是同一类型。类型推导会丢失引用和cv语义，可以使用auto&amp;保留，万能引用auto&amp;&amp;,会根据初始值属性判断是左值还是右值引用。常见于lambda表达式。<br>
<strong>decltype</strong>:推导表达式的类型（保留所有信息)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">20</span>;     <span class="hljs-comment">// b 为 int</span><br><span class="hljs-keyword">decltype</span>(a + <span class="hljs-number">3.14</span>) c;   <span class="hljs-comment">// c 为 double[5](@ref)</span><br></code></pre></td></tr></table></figure>
<h2 id="function-lambda-bind之间的关系？">function,lambda,bind之间的关系？</h2>
<p>​Lambda 和 std::bind 是生产者，生成可调用的对象。function是消费者，管理各类对象并提供一致的调用接口。</p>
<ul>
<li>function：通用可调用对象的包装器，支持类型擦除，统一存储 Lambda、std::bind 结果等。依赖其他可调用对象作为其内容。</li>
<li>lambda：生成匿名函数对象（闭包），可捕获外部变量，提供简洁的语法定义临时函数。可独立使用，或作为 std::function/std::bind 的输入。优点是直接内联，系统开销小。</li>
<li>bind：绑定函数的部分参数，生成新的可调用对象，支持参数重排和占位符机制。常常绑定普通函数、成员函数或 Lambda。</li>
</ul>
<h2 id="继承下的构造函数和析构函数执行顺序？">继承下的构造函数和析构函数执行顺序？</h2>
<p>继承下，构造函数按照依赖链，从上到下进行构造，析构函数是自下往上进行析构。</p>
<h2 id="虚函数表和虚函数表指针的创建时机？">虚函数表和虚函数表指针的创建时机？</h2>
<ul>
<li>虚函数表的创建时机：<strong>编译期生成</strong>。当编译器检测到类中包含 virtual 关键字修饰的虚函数（或继承自基类的虚函数）时，会为该类生成一个虚函数表。虚函数表是一个函数指针数组，按虚函数在类中的声明顺序存储其地址。若派生类重写了基类虚函数，则表中存储派生类函数的地址；未重写则保留基类函数地址。</li>
<li>虚函数表指针的创建时机：<strong>运行期</strong>对象构造时初始化​。vptr 是对象级别的成员，每个对象独立拥有。它在对象构造阶段被初始化，由编译器在构造函数中插入代码完成。vptr 位于对象内存布局的起始位置，指向所属类的虚函数表。</li>
</ul>
<h2 id="虚析构函数的作用？">虚析构函数的作用？</h2>
<p>虚析构函数的作用：</p>
<ul>
<li><strong>确保完整的析构链调用</strong>：当基类指针指向派生类对象时，若基类析构函数未声明为虚函数，delete该指针只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类独有的资源（如动态内存、文件句柄等）无法释放，引发内存泄漏或资源泄漏。虚析构函数通过动态绑定机制，确保delete基类指针时，先调用派生类析构函数，再调用基类析构函数，形成完整的析构链。</li>
</ul>
<p>虚析构函数的<strong>适用场景</strong>：</p>
<ul>
<li>​多态基类必须使用虚析构</li>
<li>​抽象接口类</li>
<li>含动态资源的派生类</li>
</ul>
<h2 id="C-11有哪些主要特性？">C++11有哪些主要特性？</h2>
<p>C++11主要特性：</p>
<ul>
<li>1.类型推导</li>
<li>2.智能指针</li>
<li>3.右值引用和移动语义</li>
<li>4.constexpr 编译时计算</li>
</ul>
<h2 id="动态库和静态库的区别？">动态库和静态库的区别？</h2>
<ul>
<li>静态库​：通过编译器生成目标文件，再用归档工具打包成.a或.lib文件。编译时直接嵌入库代码，符号在链接阶段解析完成。适合嵌入式系统或离线环境。程序启动时<strong>自动加载</strong>。牺牲空间换取独立性和启动速度，适合封闭环境或资源隔离需求。</li>
<li>​动态库​：编译时添加-fPIC（位置无关码）和-shared选项，生成.so或.dll文件。运行时通过动态加载器解析符号地址。运行时通过API<strong>手动加载</strong>。牺牲部署复杂度换取灵活性和资源共享，适合模块化系统或高频更新场景。</li>
</ul>
<h2 id="右值引用和左值引用的区别？">右值引用和左值引用的区别？</h2>
<p><strong>左值引用</strong>的作用​：</p>
<ul>
<li>​减少拷贝​：作为函数参数或返回值时避免数据复制。</li>
<li>​修改原对象​：通过引用直接操作原始数据。</li>
<li>​生命周期管理​：const T&amp; 可延长临时对象的生命周期至引用作用域结束。</li>
</ul>
<p><strong>右值引用</strong>的作用：</p>
<ul>
<li>通过&quot;窃取&quot;临时对象的资源（如堆内存），避免深拷贝。</li>
<li>完美转发：在模板中保持参数的原始值类别（左值/右值），通过forward转发。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-built_in">target</span>(std::forward&lt;T&gt;(arg)); <span class="hljs-comment">// 保留左值/右值属性</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-什么时候生成默认拷贝构造函数？">C++什么时候生成默认拷贝构造函数？</h2>
<p>默认拷贝构造函数（执行浅拷贝）在以下四种情况下会被编译器自动生成：</p>
<ul>
<li>类成员包含有拷贝构造函数的类对象</li>
<li>类继承自有拷贝构造函数的基类</li>
<li>类包含虚函数</li>
<li>​类存在虚继承</li>
</ul>
<h2 id="C-类型推导为什么会有额外的开销？">C++类型推导为什么会有额外的开销？</h2>
<p>C++的类型推导之所以会有额外的开销，是因为以下几个原因：</p>
<ul>
<li>1.推导规则复杂：auto会忽略初始化表达式的顶层const、引用和数组退化。需编译器多步分析。decltype的值类别敏感，需根据表达式是变量、函数调用或带括号的左值，分别应用不同规则推导。</li>
<li>2.模板实例化负担：在模板中使用auto或decltype推导返回值时，可能触发多次模板实例化。</li>
<li>3.​意外的值拷贝:若初始化表达式返回引用，但auto未显式声明引用，会进行值拷贝。</li>
</ul>
<h2 id="C-如何搜索链接到so动态库中的符号的？">C++如何搜索链接到so动态库中的符号的？</h2>
<p>C++链接到动态库的过程：</p>
<ul>
<li>​动态库加载与初始化：操作系统通过 mmap 将库文件映射到进程地址空间，动态链接器解析库的依赖关系，递归加载所有依赖库。</li>
<li>符号查找顺序：动态链接器按固定顺序解析符号，先加载主程序符号表，再进行广度搜索逐层加载动态库，最后加载全局符号表</li>
<li>使用符号绑定机制：符号绑定机制分为立即绑定和延迟绑定，延迟绑定通过全局偏移表实现符号的解析。</li>
</ul>
<h2 id="vector与普通数组的区别？vector扩容如何影响复杂度？">vector与普通数组的区别？vector扩容如何影响复杂度？</h2>
<p>vector和数组的区别在于：vector是动态大小，能够自动管理堆内存，有边界检查，并提供了一些功能接口。vector扩容时会将老的元素复制到新开辟的内存空间中，频繁扩容会导致性能下滑。</p>
<h2 id="进程同步的技术有哪些？">进程同步的技术有哪些？</h2>
<p>进程同步技术主要用于协调多个进程对共享资源的访问，避免竞态条件（Race Condition）和数据不一致问题。</p>
<ul>
<li>互斥锁：通过锁定机制确保同一时刻只有一个进程能访问临界区资源。适用于简单共享资源的<strong>独占访问</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">critical_section</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 自动加锁</span><br>    <span class="hljs-comment">// 访问共享资源</span><br>&#125; <span class="hljs-comment">// 自动解锁</span><br></code></pre></td></tr></table></figure>
<ul>
<li>​信号量：通过计数器控制<strong>多个进程</strong>对共享资源的访问权限。适用于资源池的管理。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><span class="hljs-function">std::counting_semaphore&lt;10&gt; <span class="hljs-title">sem</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 允许3个进程同时访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access_resource</span><span class="hljs-params">()</span> </span>&#123;<br>    sem.<span class="hljs-built_in">acquire</span>(); <span class="hljs-comment">// 获取信号量</span><br>    <span class="hljs-comment">// 使用资源</span><br>    sem.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放信号量</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>条件变量：允许进程等待特定条件成立后再继续执行，需与互斥锁配合使用。通过wait()释放锁并阻塞，通过notify_one()或notify_all()唤醒等待进程。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br>std::condition_variable cv;<br><span class="hljs-type">bool</span> data_ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    cv.<span class="hljs-built_in">wait</span>(lock, []&#123; <span class="hljs-keyword">return</span> data_ready; &#125;); <span class="hljs-comment">// 等待条件满足</span><br>    <span class="hljs-comment">// 消费数据</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>屏障：强制多个进程在指定同步点等待，直到所有进程到达后才继续执行。主要适用于并行计算中分阶段任务等场景。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><span class="hljs-function">std::barrier <span class="hljs-title">sync_point</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 等待5个进程</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 阶段1任务</span><br>    sync_point.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 同步点</span><br>    <span class="hljs-comment">// 阶段2任务</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>原子操作：通过硬件指令保证对单个变量的操作不可分割，避免数据竞争。主要适用于高频计数器、无锁数据结构等场景。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    counter.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>读写锁：允许多个进程同时读取共享资源，但<strong>写入时需独占访问</strong>。适用于读多写少的共享数据（如配置信息）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br>std::shared_mutex rw_mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mutex)</span></span>; <span class="hljs-comment">// 共享锁（可并发读）</span><br>    <span class="hljs-comment">// 读取数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mutex)</span></span>; <span class="hljs-comment">// 独占锁（互斥写）</span><br>    <span class="hljs-comment">// 写入数据</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="malloc和new的具体实现？">malloc和new的具体实现？</h2>
<ul>
<li>malloc是C标准库函数，其核心是通过操作系统提供的系统调用管理堆内存。使用分配的内存块头部存储元数据，通过链表链接所有空闲块。</li>
<li>new是C++运算符，其行为包含内存分配和对象构造两阶段，内存分配阶段调用全局operator new函数，默认实现内部调用malloc。对象构造阶段用placement new在已分配内存上调用构造函数。new直接返回响应的数据类型的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));  <span class="hljs-comment">// 调用malloc分配内存</span><br>MyClass* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">MyClass</span>();    <span class="hljs-comment">// 在memory地址调用构造函数</span><br></code></pre></td></tr></table></figure>
<h2 id="不相关的进程间能否使用管道实现通信？">不相关的进程间能否使用管道实现通信？</h2>
<p>不相关的进程之间可以通过<strong>命名管道</strong>实现通信。<br>
命名管道：<br>
命名管道通过 mkfifo() 或 mknod() 系统调用创建，在文件系统中生成一个特殊的 ​FIFO 文件​（如 ./myfifo）。该文件不存储实际数据，仅作为内核中管道缓冲区的访问入口。<br>
任何进程只要知道该文件路径，即可通过 open() 打开管道进行读写，无需亲缘关系。进程以写模式（O_WRONLY）打开管道，调用 write() 向管道写入数据。另一进程以读模式（O_RDONLY）打开管道，调用 read() 从管道读取数据。</p>
<h2 id="协程是什么？">协程是什么？</h2>
<p>C++协程（Coroutine）是C++20引入的一种轻量级并发编程机制，它允许函数在执行过程中暂停（挂起）并在稍后恢复，而无需依赖操作系统线程调度，从而简化异步编程、提高资源利用率。<br>
协程是一种特殊函数，可在执行中主动挂起，保存当前状态（局部变量、执行位置等），后续通过协程句柄恢复执行。<br>
C++20采用<strong>无栈协程模型</strong>，挂起时将上下文（局部变量、寄存器状态）存储在堆上</p>
<h2 id="C-的重载和C语言的区别在哪里？具体是如何实现？">C++的重载和C语言的区别在哪里？具体是如何实现？</h2>
<ul>
<li>C++重载的实现原理是<strong>名字修饰</strong>。汇编阶段使用修饰名生成符号，不同参数列表对应独立符号。C++重载在编译阶段生成唯一符号，链接阶段解析符号，重载解析符号，调用函数时，编译器选择参数最匹配的重载版本。</li>
<li>C语言：汇编阶段仅用函数名生成符号，同名函数导致符号重复定义。链接阶段C链接器按函数名查找地址，无法区分重载函数。</li>
</ul>
<h2 id="C和C-编译出来的文件有什么区别？">C和C++编译出来的文件有什么区别？</h2>
<p>和C++编译生成的可执行文件（如ELF、PE格式）在格式层面是兼容的（均可由操作系统加载执行），但因其语言特性差异，<strong>二进制内容</strong>存在显著区别。</p>
<ul>
<li>编译器通过名字修饰将函数名、参数类型/数量/顺序编码为唯一符号。C语言仅用函数名标识符号。</li>
<li>异常处理与运行时类型信息(RTTI)：编译器在二进制中插入异常处理框架​（如try/catch的栈回退逻辑）和RTTI数据结构​（用于dynamic_cast和typeid），以支持面向对象特性。C语言没有。</li>
<li>函数调用约定与对象模型：C++成员函数调用隐含传递this指针（通常通过寄存器或栈），而C函数无此机制。C++在main()前/后插入全局/静态对象的构造/析构代码，而C程序仅按代码顺序执行。</li>
</ul>
<h2 id="多继承把子类指针转为父类指针和单继承的区别在哪里？">多继承把子类指针转为父类指针和单继承的区别在哪里？</h2>
<p>多继承和单继承下子类指针向父类指针的转换存在本质区别，核心差异在于<strong>内存布局的复杂性和指针偏移机制</strong>。</p>
<ul>
<li>单继承：子类对象的内存布局为父类部分在前，子类新增部分在后。子类指针Derived<em>转换为父类指针Base</em>时，​地址不变。因父类部分位于对象起始位置，无需调整指针。子类与父类共享一个虚表指针，位于对象起始处。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> x; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-type">int</span> y; &#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>多继承：子类对象<strong>按继承顺序排列</strong>多个父类，​每个父类占据独立内存区域。转换到第一个父类​（如Base1*）时地址不变（与单继承相同）。转换到非第一个父类​（如Base2*）时，​编译器自动添加偏移量，指向Base2在子类中的起始位置。​每个含虚函数的父类在子类中<strong>独立维护虚表指针</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123; <span class="hljs-type">int</span> b; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123; <span class="hljs-type">int</span> c; &#125;;<br></code></pre></td></tr></table></figure>
<h2 id="有的类把析构函数声明为虚函数，什么场景下会用到？">有的类把析构函数声明为虚函数，什么场景下会用到？</h2>
<p>将析构函数声明为虚函数的核心目的是<strong>解决基类指针指向派生类对象时的资源正确释放问题</strong>，避免内存泄漏和未定义行为。</p>
<ul>
<li>多态基类（通过基类指针删除派生类对象）：当基类指针指向派生类对象，且基类析构函数非虚时，delete该指针仅调用基类析构函数，派生类的析构函数不被执行，导致派生类资源（如动态内存、文件句柄等）泄漏。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 释放派生类资源 */</span> &#125;<br>&#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 正确调用顺序：Derived::~Derived() → Base::~Base()</span><br></code></pre></td></tr></table></figure>
<ul>
<li>抽象类（含纯虚函数的接口类）:强制派生类实现析构逻辑，确保多态销毁安全。抽象类本身不可实例化，但需为纯虚析构函数提供定义（空实现即可）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractBase</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚析构</span><br>&#125;;<br>AbstractBase::~<span class="hljs-built_in">AbstractBase</span>() &#123;&#125;   <span class="hljs-comment">// 必须定义</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Impl</span> : <span class="hljs-keyword">public</span> AbstractBase &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Impl</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 资源释放 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>工厂模式返回基类指针:工厂函数返回基类指针（实际指向派生类对象），需通过基类指针统一管理对象生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Base* <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(); &#125;<br>&#125;;<br><br>Base* obj = Factory::<span class="hljs-built_in">createObject</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 依赖虚析构正确释放Derived资源</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多层级继承结构：若中间层基类（非最顶层）可能被多态使用，其析构函数也需为虚函数，以确保析构链完整执行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>(); &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Middle</span>(); &#125;; <span class="hljs-comment">// 必须为虚</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Middle &#123; ~<span class="hljs-built_in">Derived</span>(); &#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 调用顺序：Derived → Middle → Base</span><br></code></pre></td></tr></table></figure>
<h2 id="unique指针在编译期如何保证是真的unique？">unique指针在编译期如何保证是真的unique？</h2>
<p>unique_ptr实现真的unique是靠的以下几个机制：</p>
<ul>
<li><strong>禁用拷贝语义</strong>(核心)：unique_ptr 内部将拷贝构造函数和拷贝赋值运算符声明为 = delete，直接禁止复制行为。</li>
<li>仅支持移动语义：unique_ptr 允许通过移动操作转移所有权，转移后原指针变为 nullptr。临时右值可隐式移动。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = std::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure>
<ul>
<li>编译器的静态检查:类型系统强制约束,如当尝试拷贝时，编译器检查到调用了被删除的函数，直接报错。</li>
</ul>
<h2 id="移动语义如何使用？">移动语义如何使用？</h2>
<p>移动语义是C++11引入的核心特性，通过转移资源所有权而非复制资源，显著提升程序性能。绑定临时对象（右值），标记可被&quot;窃取&quot;资源的对象。使用move将左值强制转换为右值引用，触发移动语义。需定义移动构造函数和移动赋值运算符，并标记noexcept以保证异常安全。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2 = std::<span class="hljs-built_in">move</span>(s1);  <span class="hljs-comment">// s1的资源被转移给s2，s1变为空</span><br></code></pre></td></tr></table></figure>
<h2 id="emplace-back和push-back的区别？">emplace_back和push_back的区别？</h2>
<p>两者均为容器尾部添加元素的方法，但<strong>底层机制</strong>和<strong>适用场景</strong>不同。</p>
<ul>
<li>push_back:先构造临时对象，再拷贝/移动到容器中.</li>
<li>emplace_back:​直接在容器内存中构造对象，避免临时对象创建和拷贝/移动。减少了构造临时对象这一步，性能更优。不支持初始化列表，存在隐式类型转换风险。<br>
结论：emplace_back的效率相对更高，因此在代码中<strong>尽量用emplace_back</strong>代替push_back。</li>
</ul>
<h2 id="deque和vector的区别？内存布局有啥区别？">deque和vector的区别？内存布局有啥区别？</h2>
<ul>
<li>queue:​分段连续存储，由多个固定大小的内存块（chunks）组成，通过中控器（指针数组）管理逻辑连续性。动态分配新内存块，只需更新中控器的指针，​无需移动现有元素。扩容成本更低。无法保证整体内存连续。需高频头尾操作时使用queue。</li>
<li>vector:​单块连续内存，元素<strong>物理地址连续</strong>,容量不足时，重新分配一块更大的连续内存,严格连续，支持直接传递首地址。操作集中在尾部。</li>
</ul>
<h2 id="weak-ptr如何解决循环引用？">weak_ptr如何解决循环引用？</h2>
<p>weak_ptr 是 C++11 引入的智能指针，专为配合 shared_ptr 解决循环引用问题而设计，同时提供安全的对象访问机制。循环引用指两个或多个对象通过 shared_ptr 相互持有，导致引用计数无法归零，对象无法释放。<br>
weak_ptr 通过​<strong>非拥有式观察</strong>打破循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    std::shared_ptr&lt;B&gt; b_ptr;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">/*出现循环引用*/</span><br>    <span class="hljs-comment">//std::shared_ptr&lt;A&gt; a_ptr;</span><br>    <span class="hljs-comment">/*修改为 weak_ptr解决循环引用*/</span><br>    std::weak_ptr&lt;A&gt; a_ptr;  <br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="weak-ptr如何升级为shared-ptr？">weak_ptr如何升级为shared_ptr？</h2>
<p>weak_ptr 通过 lock() 方法安全升级为 shared_ptr，确保访问对象时其未被销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::weak_ptr&lt;A&gt; weak_a = ...;  <span class="hljs-comment">// 从某处获取 weak_ptr</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> shared_a = weak_a.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// 尝试升级</span><br>    shared_a-&gt;<span class="hljs-built_in">do_something</span>();       <span class="hljs-comment">// 对象存活，安全访问</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 对象已销毁，避免悬垂指针</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>weak_ptr 通过控制块中的​弱引用计数​感知对象状态：<br>
​构造时​：复制 shared_ptr 的控制块指针，弱引用计数 +1。<br>
​析构时​：弱引用计数 -1，若弱引用计数和强引用计数均为 0，释放控制块。<br>
​<strong>lock() 时</strong>​：检查控制块中的强引用计数，决定是否构造新 shared_ptr。</p>
<h2 id="C-的左值和右值是如何使用的？">C++的左值和右值是如何使用的？</h2>
<ul>
<li>左值：具有持久存储位置的对象，可被取地址（&amp;操作符），通常有变量名，可多次使用。可出现在赋值左侧，生命周期在作用域内有效。</li>
<li>右值：临时对象或字面量，无持久存储位置，不可取地址，通常为一次性使用的值。仅能出现在赋值右侧，生命周期在表达式结束时结束。</li>
</ul>
<h2 id="C-14的新特性？">C++14的新特性？</h2>
<p>C++14主要是对一些C++11的已有特性做了扩展。</p>
<ul>
<li>支持更灵活的类型推导，C++14支持decltype(auto),这个auto仅仅作为占位符使用。</li>
<li>constexpr支持更加广泛的语法和应用，如可以使用局部变量。</li>
<li>支持更加通用的lambda表达式，允许表达式内部使用auto参数，处理泛型类型更方便。</li>
<li>支持返回类型推导</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//推导出来是int类型的返回值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> num2=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num3=<span class="hljs-built_in">add</span>(num1,num2);<br>    cout&lt;&lt;num3;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17的新特性？">C++17的新特性？</h2>
<ul>
<li>结构化绑定：允许通过一个简单的声明将元组或其他数据结构的成员绑定到变量。</li>
<li>if初始化：在 if 和 switch 语句中可以直接初始化变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num4 = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span> &lt; num4)<span class="hljs-comment">//C++17支持if初始化</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++17 yes&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>折叠表达式：支持更灵活的模板元编程</li>
<li>constexpr lambda 表达式：允许 lambda 表达式在编译时进行求值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个 constexpr lambda 表达式，用于计算两个整数的和</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">constexpr</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br><br>    <span class="hljs-comment">// 在编译时调用 lambda 表达式</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>std::optional：提供了一种可选值的容器，用于解决空指针的问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个可能返回无效值的函数，使用 optional 来安全地表示结果</span><br><span class="hljs-function">optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回无值状态</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> numerator / denominator;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> result1 = <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (result<span class="hljs-number">1.</span><span class="hljs-built_in">has_value</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Result of 10 / 2: &quot;</span> &lt;&lt; result<span class="hljs-number">1.</span><span class="hljs-built_in">value</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Division by zero error.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> result2 = <span class="hljs-built_in">divide</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 除以零，应该失败</span><br>    <span class="hljs-keyword">if</span> (result2)<br>    &#123;<br>        <span class="hljs-comment">// 另一种检查方式</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Result of 5 / 0: &quot;</span> &lt;&lt; *result2 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Division by zero error.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>std::variant：提供了一种可变的类型安全的联合。</li>
<li>filesystem：提供了一个现代化的、面向对象的文件系统操作 API。</li>
</ul>
<h2 id="如何让对象只能产生在堆上？">如何让对象只能产生在堆上？</h2>
<p>将对象的<strong>析构函数设置为私有</strong>的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。</p>
<h2 id="如何让对象只能产生在栈上？">如何让对象只能产生在栈上？</h2>
<p>把构造函数禁用，使其无法new对象在堆上。</p>
<h2 id="C-指针悬挂问题是什么，如何解决？">C++指针悬挂问题是什么，如何解决？</h2>
<p>指针悬挂是C++中因内存管理不当导致的常见问题，指指针指向的内存已被释放或失效，但指针仍保留原地址。访问此类指针会引发未定义行为​。以下是一些常见的场景和解决方法。</p>
<ul>
<li>指针释放后未置空：内存释放后，指针未置空，仍指向无效地址。解决方法是释放内存后立即置空指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*指针释放后未置空的场景*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 动态分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Before delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 释放内存</span><br>*p = <span class="hljs-number">30</span>; <span class="hljs-comment">// 未定义行为：使用已释放的内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;After delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 操作悬空指针</span><br><br><span class="hljs-comment">/*指针释放后立即置空指针的场景*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 动态分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Before delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 释放内存</span><br>p=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将指针置空</span><br></code></pre></td></tr></table></figure>
<ul>
<li>返回局部变量地址：函数返回局部变量的指针，局部变量销毁后指针失效。解决方法是避免返回局部对象指针/引用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*返回局部变量地址的场景*/</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createDangling</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">return</span> &amp;x; <span class="hljs-comment">// 返回后x销毁，指针悬空</span><br>&#125;<br><span class="hljs-comment">/*返回动态分配内存或静态变量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createSafe</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 调用者需负责delete操作</span><br>&#125;    <br></code></pre></td></tr></table></figure>
<ul>
<li>容器内存重分配：容器扩容导致内存重新分配，原有元素指针失效。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*容器内存重分配的场景*/</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;vec[<span class="hljs-number">0</span>];<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 内存重分配，p悬空</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多指针共享同一内存​：多个指针指向同一内存，其中一个释放内存后，其余指针未更新。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*多指针共享同一内存的场景*/</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span>* p2 = p1;<br><span class="hljs-keyword">delete</span> p1; <span class="hljs-comment">// p1和p2均悬空</span><br></code></pre></td></tr></table></figure>
<h2 id="C-中的特化和偏特化是什么？">C++中的特化和偏特化是什么？</h2>
<p>C++中的模板特化和偏特化是模板编程中用于针对特定类型或条件提供定制化实现的高级技术，旨在<strong>优化性能、处理特殊逻辑或增强类型安全性</strong>。</p>
<ul>
<li>
<p>模板特化(全特化)：为模板的所有参数指定具体类型，完全覆盖通用模板的实现。</p>
</li>
<li>
<p>模板偏特化：仅对模板的部分参数进行特化，其余参数保持泛型。</p>
</li>
</ul>
<pre><code class="language-c++">/*模板全特化和偏特化的例子*/
#include &lt;iostream&gt;
using namespace std;

// 主模板
template &lt;typename T&gt;
class Vector &#123;
private:
    T* data;
    size_t size;

public:
    Vector(size_t s) : size(s) &#123;
        data = new T[size];
    &#125;

    ~Vector() &#123;
        delete[] data;
    &#125;

    void info() &#123;
        cout &lt;&lt; &quot;通用Vector&quot; &lt;&lt; endl;
    &#125;
&#125;;

// 全特化：bool 类型
template &lt;&gt;
class Vector&lt;bool&gt; &#123;
private:
    unsigned char* compressedData; // 使用位压缩存储 bool 数组

public:
    Vector(size_t size) &#123;
        compressedData = new unsigned char[(size + 7) / 8];
    &#125;

    ~Vector() &#123;
        delete[] compressedData;
    &#125;

    void info() &#123;
        cout &lt;&lt; &quot;特化BoolVector&quot; &lt;&lt; endl;
    &#125;
&#125;;

// 偏特化：所有指针类型的 Vector&lt;T*&gt;
template &lt;typename T&gt;
class Vector&lt;T*&gt; &#123;
private:
    T** data;
    size_t size;

public:
    Vector(size_t s) : size(s) &#123;
        data = new T*[size];
    &#125;

    ~Vector() &#123;
        delete[] data;
    &#125;

    void info() &#123;
        cout &lt;&lt; &quot;偏特化PointerVector&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main() &#123;
    Vector&lt;int&gt; v1(10);       // 调用主模板
    v1.info();                // 输出: 通用Vector

    Vector&lt;bool&gt; v2(10);      // 调用全特化
    v2.info();                // 输出: 特化BoolVector

    Vector&lt;int*&gt; v3(10);      // 调用偏特化
    v3.info();                // 输出: 偏特化PointerVector

    return 0;
&#125;

// 定义一个支持显式构造的类
class MyClass
&#123;
public:
    // 使用 explicit 防止隐式转换
    explicit MyClass(int value) : data(value)
    &#123;
        std::cout &lt;&lt; &quot;Explicit constructor called with value: &quot; &lt;&lt; data &lt;&lt; std::endl;
    &#125;

    void printData() const
    &#123;
        std::cout &lt;&lt; &quot;Data: &quot; &lt;&lt; data &lt;&lt; std::endl;
    &#125;

private:
    int data;
&#125;;

// 演示没有 explicit 的情况
class MyOtherClass
&#123;
public:
    MyOtherClass(int value) : data(value)
    &#123;
        std::cout &lt;&lt; &quot;Non-explicit constructor called with value: &quot; &lt;&lt; data &lt;&lt; std::endl;
    &#125;

    void printData() const
    &#123;
        std::cout &lt;&lt; &quot;MyOtherClass Data: &quot; &lt;&lt; data &lt;&lt; std::endl;
    &#125;

private:
    int data;
&#125;;

int main()
&#123;
    // 显式调用 MyClass 构造函数（必须的，因为构造函数被声明为 explicit）
    MyClass obj1(10);
    obj1.printData();

    // 下面这行会编译失败，因为 explicit 禁止了隐式转换
    // MyClass obj2 = 20;

    // 正确写法：显式调用构造函数
    MyClass obj2 = MyClass(20);
    obj2.printData();

    // 对于没有 explicit 的类，允许隐式转换
    MyOtherClass obj3 = 30; // 隐式转换合法
    obj3.printData();

    return 0;
&#125;</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" class="category-chain-item">技术分享</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/c/" class="print-no-link">#c++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c++八股文</div>
      <div>https://emopps.github.io/2025/07/24/c++八股文/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>emopps</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/" title="操作系统八股文">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统八股文</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/" title="计算机网络八股文">
                        <span class="hidden-mobile">计算机网络八股文</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
