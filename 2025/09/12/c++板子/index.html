

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="emopps">
  <meta name="keywords" content="">
  
    <meta name="description" content="数据结构与算法模板 1 基础模板 12345678910111213141516171819202122#include &lt;bits&#x2F;stdc++.h&gt;#define endl &#x27;\n&#x27;#define int long longusing namespace std;void solve()&#123;    &#x2F;&#x2F; 解题&#125;signed main()&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法模板">
<meta property="og:url" content="https://emopps.github.io/2025/09/12/c++%E6%9D%BF%E5%AD%90/index.html">
<meta property="og:site_name" content="emopps">
<meta property="og:description" content="数据结构与算法模板 1 基础模板 12345678910111213141516171819202122#include &lt;bits&#x2F;stdc++.h&gt;#define endl &#x27;\n&#x27;#define int long longusing namespace std;void solve()&#123;    &#x2F;&#x2F; 解题&#125;signed main()&amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-12T10:09:53.000Z">
<meta property="article:modified_time" content="2025-09-12T10:10:38.283Z">
<meta property="article:author" content="emopps">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>数据结构与算法模板 - emopps</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"emopps.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>emopps</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法模板"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-12 18:09" pubdate>
          2025年9月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          120 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构与算法模板</h1>
            
            
              <div class="markdown-body">
                
                <h1>数据结构与算法模板</h1>
<h1>1 基础模板</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 解题</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; t; <span class="hljs-comment">// 单测则注释</span><br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>2 算法 Algorithm</h1>
<h2 id="2-1-埃式筛-埃拉托斯特尼筛法-Eratosthenes">2.1 埃式筛 埃拉托斯特尼筛法 Eratosthenes</h2>
<p>时间复杂度：$O(n\log\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> is_prime[MAXN]; <span class="hljs-comment">// is_prime储存该数是否为素数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(is_prime, <span class="hljs-literal">true</span>, <span class="hljs-built_in">sizeof</span>(is_prime));<br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 特判0、1不是素数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; i++)     <span class="hljs-comment">// 使用埃氏筛处理&gt;1的情况</span><br>        <span class="hljs-keyword">if</span> (is_prime[i])<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j * i &lt; MAXN; j++)<br>                is_prime[i * j] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-2-欧拉筛-线性筛-Euler">2.2 欧拉筛 线性筛 Euler</h2>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// prime储存素数序列，primesize即素数数量，not_prime储存该数是否不是素数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> prime[MAXN], primesize = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> not_prime[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    not_prime[<span class="hljs-number">0</span>] = not_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 特判0、1不是素数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; i++)      <span class="hljs-comment">// 使用欧拉筛处理&gt;1的情况</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!not_prime[i])<br>            prime[primesize++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primesize &amp;&amp; i * prime[j] &lt; MAXN; j++)<br>        &#123;<br>            not_prime[i * prime[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-3-二分查找-Binary-Search">2.3 二分查找 Binary Search</h2>
<p>时间复杂度：$O(\log n)$</p>
<h3 id="2-3-1-geq-x">2.3.1 $\geq x$</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a[ ]为储存数据的有序递增数组</span><br><span class="hljs-comment">// l ~ r为二分查找的数组范围</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= x)<br>        r = mid;<br>    <span class="hljs-keyword">else</span><br>        l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-2-leq-x">2.3.2 $\leq x$</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a[ ]为储存数据的有序递增数组</span><br><span class="hljs-comment">// l ~ r为二分查找的数组范围</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &lt;= x)<br>        l = mid;<br>    <span class="hljs-keyword">else</span><br>        r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-3-实数">2.3.3 实数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// check(int x): 判断x是否满足条件</span><br><span class="hljs-comment">// eps: 精度（因为浮点数误差，不可直接比大小）</span><br><span class="hljs-comment">// BEGIN: 查找左边界</span><br><span class="hljs-comment">// END: 查找右边界</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">double</span> l = BEGIN, r = END;<br><span class="hljs-keyword">while</span> (r - l &gt; eps)<br>&#123;<br>    <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))<br>        l = mid;<br>    <span class="hljs-keyword">else</span><br>        r = mid;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-4-三分查找">2.4 三分查找</h2>
<p>时间复杂度：$O(\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// f(double x): 给定区间内的凹函数或凸函数</span><br><span class="hljs-comment">// eps: 精度（因为浮点数误差，不可直接比大小）</span><br><span class="hljs-comment">// BEGIN: 查找左边界</span><br><span class="hljs-comment">// END: 查找右边界</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;<br><span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">double</span> l = BEGIN, r = END;<br><span class="hljs-keyword">while</span>(r - l &gt; eps)<br>&#123;<br>    <span class="hljs-type">double</span> m1 = l + (r - l) / <span class="hljs-number">3</span>, m2 = r - (r - l) / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(m1) &gt; <span class="hljs-built_in">f</span>(m2)) <span class="hljs-comment">// 此为找最小值，若要找最大值，则改为&lt;</span><br>        l = m1;<br>    <span class="hljs-keyword">else</span><br>        r = m2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-5-深度优先搜索-DFS">2.5 深度优先搜索 DFS</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">type <span class="hljs-title">dfs</span><span class="hljs-params">(type x, ... )</span> <span class="hljs-comment">// 可以存在多个变量</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( ... ) <span class="hljs-comment">// 达成目标，找到答案</span><br>    &#123;<br>        ... <span class="hljs-comment">// 输出答案或判断最优解等等</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( ... ) <span class="hljs-comment">// 达到搜索边界（即到边界了还没搜到，有时没有此步骤）</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( ... ) <span class="hljs-comment">// 遍历所有子节点</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>( ... ) <span class="hljs-comment">// 可以转移状态，一般用标志变量判断</span><br>        &#123;<br>            ... <span class="hljs-comment">// 修改标志变量，表明此节点不可转移</span><br>            <span class="hljs-built_in">dfs</span>( ... ) <span class="hljs-comment">// 搜索子节点，经常为x+1</span><br>            ... <span class="hljs-comment">// 还原标志变量，表面此节点可转移</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-6-广度优先搜索-BFS">2.6 广度优先搜索 BFS</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> vis[MAXN]; <span class="hljs-comment">// 标记是否搜索过，有时也可直接用depth来判断</span><br><span class="hljs-type">int</span> depth[MAXN]; <span class="hljs-comment">// 储存搜索深度，有时可能为二维数组或map</span><br>queue&lt;type&gt; que; <span class="hljs-comment">// STL队列，不过数组模拟队列效率更高</span><br><br><span class="hljs-function">type <span class="hljs-title">bfs</span><span class="hljs-params">(type start)</span></span><br><span class="hljs-function"></span>&#123;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 起点入队</span><br>    depth[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点深度0</span><br>    vis[start] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记起点</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        type now = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前节点设置为队首</span><br>        que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出队首</span><br>        <span class="hljs-keyword">if</span> ( ... ) <span class="hljs-comment">// 如果达到目标条件</span><br>        &#123;<br>            ans = depth[now]; <span class="hljs-comment">// 储存答案</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 搜索结束</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>( ... ) <span class="hljs-comment">// 遍历now节点的所有子节点，可用数组表示方向</span><br>        &#123;<br>            type next = ... <span class="hljs-comment">// 计算出子节点</span><br>            <span class="hljs-keyword">if</span> (!vis[next] &amp;&amp; ... ) <span class="hljs-comment">// 如果子节点未搜索过，且范围符合题目条件</span><br>            &#123;<br>                vis[next] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记子节点</span><br>                depth[next] = depth[now] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 子节点深度+1</span><br>                que.<span class="hljs-built_in">push</span>(next); <span class="hljs-comment">// 子节点入队</span><br>                <span class="hljs-comment">// 有时题目还需输出具体路径，可用一个数组储存每个节点的上一个节点，然后在此处对数组赋值。输出时，从结尾递归反向输出即可获得具体的路径。</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-7-辗转相除法-欧几里得算法-Euclidean-algorithm">2.7 辗转相除法 欧几里得算法 Euclidean algorithm</h2>
<p>时间复杂度：$O(\log(a+b))$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-8-快速幂-Exponentiation-by-squaring">2.8 快速幂 Exponentiation by squaring</h2>
<p>时间复杂度：$O(\log n)$</p>
<h3 id="2-8-1-不取模">2.8.1 不取模</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">fast_pow</span><span class="hljs-params">(ll a, ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * a;<br>        a = a * a;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-8-2-取模">2.8.2 取模</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> ll MOD = <span class="hljs-number">20220128</span>;<br><span class="hljs-function">ll <span class="hljs-title">fast_pow</span><span class="hljs-params">(ll a, ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a %= MOD; <span class="hljs-comment">// 开头先取一次模</span><br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * a % MOD; <span class="hljs-comment">// 每次运算都取模</span><br>        a = a * a % MOD; <span class="hljs-comment">// 每次运算都取模</span><br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-9-KMP-算法-The-Knuth-Morris-Pratt-Algorithm">2.9 KMP 算法 The Knuth-Morris-Pratt Algorithm</h2>
<p>时间复杂度：$O(n+m)$</p>
<h3 id="2-9-1-类封装">2.9.1 类封装</h3>
<p>使用时先构造 <code>KMP</code>，传入参数为<strong>模式串（Pattern）</strong>.</p>
<p>匹配时调用 <code>.find()</code>，传入参数为<strong>主串（Text）</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KMP</span><br>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nxt;<br>    string pat;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">KMP</span>(string &amp;s)<br>    &#123;<br>        pat = s;<br>        <span class="hljs-type">int</span> n = pat.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        nxt.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; pat[i] != pat[j])<br>                j = nxt[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (pat[i] == pat[j])<br>                j++;<br>            nxt[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">find</span><span class="hljs-params">(string &amp;txt)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = pat.<span class="hljs-built_in">length</span>(), m = txt.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; txt[i] != pat[j])<br>                j = nxt[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (txt[i] == pat[j])<br>                j++;<br>            <span class="hljs-keyword">if</span> (j == n)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(i - n + <span class="hljs-number">1</span>);<br>                j = nxt[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_border</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> cur = nxt.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            s.<span class="hljs-built_in">insert</span>(cur);<br>            cur = nxt[cur - <span class="hljs-number">1</span>];<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-9-1-旧模板">2.9.1 旧模板</h3>
<p><strong>计算部分匹配表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> s1[MAXN]; <span class="hljs-comment">// 主串</span><br><span class="hljs-type">char</span> s2[MAXN]; <span class="hljs-comment">// 模式串</span><br><span class="hljs-type">int</span> nxt[MAXN]; <span class="hljs-comment">// 部分匹配表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    nxt[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> lens2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-keyword">while</span> (i &lt; lens2)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s2[i] == s2[j])<br>        &#123;<br>            ++i;<br>            ++j;<br>            nxt[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            j = nxt[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>找所有匹配</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> s1[MAXN]; <span class="hljs-comment">// 主串</span><br><span class="hljs-type">char</span> s2[MAXN]; <span class="hljs-comment">// 模式串</span><br><span class="hljs-type">int</span> nxt[MAXN]; <span class="hljs-comment">// 部分匹配表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> lens1 = <span class="hljs-built_in">strlen</span>(s1), lens2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-keyword">while</span> (i &lt; lens1)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s1[i] == s2[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            j = nxt[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == lens2)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>找第一个匹配</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> s1[MAXN]; <span class="hljs-comment">// 主串</span><br><span class="hljs-type">char</span> s2[MAXN]; <span class="hljs-comment">// 模式串</span><br><span class="hljs-type">int</span> nxt[MAXN]; <span class="hljs-comment">// 部分匹配表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> lens1 = <span class="hljs-built_in">strlen</span>(s1), lens2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-keyword">while</span> (i &lt; lens1 &amp;&amp; j &lt; lens2)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s1[i] == s2[j])<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            j = nxt[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == lens2)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>); <span class="hljs-comment">// -1表示没匹配到结果</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-10-Dijkstra-算法">2.10 Dijkstra 算法</h2>
<p>解决赋权图的单源最短路径问题，<strong>不能解决负边</strong>。</p>
<h3 id="2-10-1-朴素（适合稠密图）">2.10.1 朴素（适合稠密图）</h3>
<p>时间复杂度：$O(|V|^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// INF代表无穷大</span><br><span class="hljs-type">int</span> g[MAXN][MAXN]; <span class="hljs-comment">// 邻接矩阵存图</span><br><span class="hljs-type">int</span> dist[MAXN];    <span class="hljs-comment">// 最短距离</span><br><span class="hljs-type">bool</span> vis[MAXN];    <span class="hljs-comment">// 访问情况</span><br><span class="hljs-type">int</span> v, e;          <span class="hljs-comment">// v顶点数 e边数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)<br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        vis[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-10-2-堆优化（适合稀疏图）">2.10.2 堆优化（适合稀疏图）</h3>
<p>时间复杂度：$O((\left|E\right|+\left|V\right|)\log\left|V\right|)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;           <span class="hljs-comment">// INF代表无穷大</span><br><span class="hljs-type">int</span> E, V, S;                                         <span class="hljs-comment">// E边数，V顶点数，S起点</span><br>vector&lt;PII&gt; edge[MAXN];                              <span class="hljs-comment">// 储存连接关系，二元组为(权值,终点)</span><br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pque; <span class="hljs-comment">// 储存节点，节点距离小的在堆顶</span><br><span class="hljs-type">int</span> dist[MAXN];                                      <span class="hljs-comment">// 储存节点距离</span><br><span class="hljs-type">bool</span> vis[MAXN];                                      <span class="hljs-comment">// 是否已经访问过该节点的标志</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    pque.<span class="hljs-built_in">push</span>(&#123;dist[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!pque.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        PII cur = pque.<span class="hljs-built_in">top</span>();<br>        pque.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[cur.second])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[cur.second] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> next : edge[cur.second])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dist[next.second] &gt; dist[cur.second] + next.first)<br>            &#123;<br>                dist[next.second] = dist[cur.second] + next.first;<br>                <span class="hljs-keyword">if</span> (!vis[next.second])<br>                    pque.<span class="hljs-built_in">push</span>(&#123;dist[next.second], next.second&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-11-Floyd-Warshall-算法">2.11 Floyd-Warshall 算法</h2>
<p>解决赋权图的多源最短路径问题，能解决负边，不能解决负环。</p>
<p>时间复杂度：$O(\left|V\right|^3)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> e, v;             <span class="hljs-comment">// e边数 v顶点数</span><br><span class="hljs-type">int</span> dist[MAXN][MAXN]; <span class="hljs-comment">// dist[x][y]代表x到y的距离</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++)<br>        dist[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= v; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)<br>                <span class="hljs-keyword">if</span> (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF)<br>                    dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-12-最短路径快速算法-SPFA">2.12 最短路径快速算法 SPFA</h2>
<p>平均时间复杂度：$O(\left|E\right|)$</p>
<p>最差时间复杂度：$O(\left|V\right|\cdot\left|E\right|)$</p>
<h3 id="2-12-1-最短路">2.12.1 最短路</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// INF代表无穷大</span><br><span class="hljs-type">int</span> e, v, s;                                 <span class="hljs-comment">// e边数 v顶点数 s起点</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge[MAXN];           <span class="hljs-comment">// 邻接表存图 pair为(距离, 终点)</span><br>queue&lt;<span class="hljs-type">int</span>&gt; que;                              <span class="hljs-comment">// STL队列</span><br><span class="hljs-type">int</span> dist[MAXN];                              <span class="hljs-comment">// 最短距离</span><br><span class="hljs-type">bool</span> vis[MAXN];                              <span class="hljs-comment">// 是否入队</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> src)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[src] = <span class="hljs-number">0</span>;<br>    que.<span class="hljs-built_in">push</span>(src);<br>    vis[src] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        vis[cur] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> next : edge[cur])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dist[next.second] &gt; dist[cur] + next.first)<br>            &#123;<br>                dist[next.second] = dist[cur] + next.first;<br>                <span class="hljs-keyword">if</span> (!vis[next.second])<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(next.second);<br>                    vis[next.second] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-12-2-判负权回路">2.12.2 判负权回路</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> E, V, S;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge[MAXN];<br>queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-type">int</span> dist[MAXN], cnt[MAXN];<br><span class="hljs-type">bool</span> vis[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++)<br>    &#123;<br>        que.<span class="hljs-built_in">push</span>(i);<br>        vis[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        vis[cur] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> next : edge[cur])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dist[next.second] &gt; dist[cur] + next.first)<br>            &#123;<br>                dist[next.second] = dist[cur] + next.first;<br>                cnt[next.second] = cnt[cur] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[next.second] &gt;= V)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (!vis[next.second])<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(next.second);<br>                    vis[next.second] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-13-克鲁斯卡尔算法-Kruskal">2.13 克鲁斯卡尔算法 Kruskal</h2>
<p>时间复杂度：$O(\left|E\right|\log\left|V\right|)$</p>
<p>适合稀疏图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> v, e;     <span class="hljs-comment">// v顶点数 e边数</span><br><span class="hljs-type">int</span> fa[MAXN]; <span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>   <span class="hljs-comment">// 边的结构体，重载了&lt;供sort()</span><br>&#123;<br>    <span class="hljs-type">int</span> start, end, dist;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;x) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> dist &lt; x.dist;<br>    &#125;<br>&#125;;<br>vector&lt;Edge&gt; edges; <span class="hljs-comment">// 邻接表存边</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="hljs-built_in">find</span>(fa[x]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, selected = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed : edges)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(ed.start) != <span class="hljs-built_in">find</span>(ed.end))<br>        &#123;<br>            <span class="hljs-built_in">merge</span>(ed.start, ed.end);<br>            ans += ed.dist;<br>            <span class="hljs-keyword">if</span> (++selected == v - <span class="hljs-number">1</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag ? ans : INF;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-14-普林姆算法-Prim">2.14 普林姆算法 Prim</h2>
<h3 id="2-14-1-朴素（适合稠密图）">2.14.1 朴素（适合稠密图）</h3>
<p>时间复杂度：$O(\left|V\right|^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// INF代表无穷大</span><br><span class="hljs-type">int</span> g[MAXN][MAXN]; <span class="hljs-comment">// 邻接矩阵存图</span><br><span class="hljs-type">int</span> dist[MAXN];    <span class="hljs-comment">// 距离已选择点的最短距离</span><br><span class="hljs-type">int</span> vis[MAXN];     <span class="hljs-comment">// 点是否选择</span><br><span class="hljs-type">int</span> v, e;          <span class="hljs-comment">// v顶点数 e边数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)<br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        <span class="hljs-keyword">if</span> (dist[t] == INF)<br>            <span class="hljs-keyword">return</span> INF;<br>        ans += dist[t];<br>        vis[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-14-2-堆优化">2.14.2 堆优化</h3>
<p>时间复杂度：$O((\left|E\right|+\left|V\right|)\log\left|V\right|)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;           <span class="hljs-comment">// INF代表无穷大</span><br><span class="hljs-type">int</span> E, V;                                            <span class="hljs-comment">// E边数 V顶点数</span><br>vector&lt;PII&gt; edge[MAXN];                              <span class="hljs-comment">// 储存边，二元组为(权值,终点)</span><br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pque; <span class="hljs-comment">// 短的边在堆顶</span><br><span class="hljs-type">int</span> dist[MAXN];                                      <span class="hljs-comment">// 储存节点到已选择点的最短距离</span><br><span class="hljs-type">bool</span> vis[MAXN];                                      <span class="hljs-comment">// 是否已选择该点</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    pque.<span class="hljs-built_in">push</span>(&#123;dist[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!pque.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        PII cur = pque.<span class="hljs-built_in">top</span>();<br>        pque.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[cur.second])<br>            <span class="hljs-keyword">continue</span>;<br>        ans += cur.first;<br>        cnt++;<br>        vis[cur.second] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> next : edge[cur.second])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dist[next.second] &gt; next.first)<br>            &#123;<br>                dist[next.second] = next.first;<br>                <span class="hljs-keyword">if</span> (!vis[next.second])<br>                    pque.<span class="hljs-built_in">push</span>(&#123;dist[next.second], next.second&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == V ? ans : INF;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-15-排序算法-Sort">2.15 排序算法 Sort</h2>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最好情况</th>
<th>平均情况</th>
<th>最坏情况</th>
<th>空间占用</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序 (Bubble sort)</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$1$</td>
<td>$\text{Y}$</td>
</tr>
<tr>
<td>选择排序 (Selection sort)</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$1$</td>
<td>$\text{N}$</td>
</tr>
<tr>
<td>插入排序 (Insertion sort)</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$1$</td>
<td>$\text{Y}$</td>
</tr>
<tr>
<td>希尔排序 (Shellsort)</td>
<td>$n\log n$</td>
<td>$n^{4/3}$</td>
<td>$n^{3/2}$</td>
<td>$1$</td>
<td>$\text{N}$</td>
</tr>
<tr>
<td>归并排序 (Merge sort)</td>
<td>$n\log n$</td>
<td>$n\log n$</td>
<td>$n\log n$</td>
<td>$n$</td>
<td>$\text{Y}$</td>
</tr>
<tr>
<td>快速排序 (Quicksort)</td>
<td>$n\log n$</td>
<td>$n\log n$</td>
<td>$n^2$</td>
<td>$\log n$</td>
<td>$\text{N}$</td>
</tr>
<tr>
<td>堆排序 (Heapsort)</td>
<td>$n\log n$</td>
<td>$n\log n$</td>
<td>$n\log n$</td>
<td>$1$</td>
<td>$\text{N}$</td>
</tr>
<tr>
<td>计数排序 (Counting sort)</td>
<td>$-$</td>
<td>$n+r$</td>
<td>$n+r$</td>
<td>$n+r$</td>
<td>$\text{Y}$</td>
</tr>
<tr>
<td>桶排序 (Bucket sort)</td>
<td>$-$</td>
<td>$n+r$</td>
<td>$n+r$</td>
<td>$n+r$</td>
<td>$\text{Y}$</td>
</tr>
</tbody>
</table>
<h3 id="2-15-1-冒泡">2.15.1 冒泡</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l + <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l + <span class="hljs-number">1</span>; j &lt;= i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[j - <span class="hljs-number">1</span>] &gt; arr[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(arr[j - <span class="hljs-number">1</span>], arr[j]);<br>                swapped = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!swapped)<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-15-2-选择">2.15.2 选择</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j_min = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= r; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j_min])<br>                j_min = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j_min != i)<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j_min]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-15-3-插入">2.15.3 插入</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= l &amp;&amp; num &lt; arr[j])<br>        &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-15-4-归并">2.15.4 归并</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> tmp[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge_sort</span>(arr, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j])<br>            tmp[k++] = arr[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++] = arr[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid)<br>        tmp[k++] = arr[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)<br>        tmp[k++] = arr[j++];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = l, n = <span class="hljs-number">0</span>; m &lt;= r; m++, n++)<br>        arr[m] = tmp[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-15-5-快速">2.15.5 快速</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> x = arr[(l + r) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span><br>            i++;<br>        <span class="hljs-keyword">while</span> (arr[i] &lt; x);<br>        <span class="hljs-keyword">do</span><br>            j--;<br>        <span class="hljs-keyword">while</span> (arr[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(arr, l, j);<br>    <span class="hljs-built_in">quicksort</span>(arr, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-16-二分图-Bipartite-Graph">2.16 二分图 Bipartite Graph</h2>
<h3 id="2-16-1-染色法判二分图">2.16.1 染色法判二分图</h3>
<p>时间复杂度：$O(\left|V\right|+\left|E\right|)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> V, E;                   <span class="hljs-comment">// V为顶点，E为边</span><br>vector&lt;<span class="hljs-type">int</span>&gt; edge[SIZE];     <span class="hljs-comment">// vector邻接表，可改为数组邻接表效率更高</span><br><span class="hljs-type">int</span> color[SIZE];            <span class="hljs-comment">// 储存颜色，用0和1表示两种颜色，-1表示还未染色。重要：使用前先memset为-1</span><br><span class="hljs-comment">/* vector&lt;int&gt; ans[2]; */</span>   <span class="hljs-comment">// 储存两颜色的顶点，某些题目需要输出</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[n] = c;<br>    <span class="hljs-comment">/* ans[colr].push_back(node); */</span>   <span class="hljs-comment">// 储存两颜色的顶点，某些题目需要输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nxt : edge[n])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (color[n] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(nxt, !c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[nxt] == c)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非联通：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>))<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-16-2-最大匹配-匈牙利算法-Hungarian-Algorithm">2.16.2 最大匹配 匈牙利算法  Hungarian Algorithm</h3>
<p>时间复杂度：$O(\left|V\right|\cdot \left|E\right|)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n1, n2, m;          <span class="hljs-comment">// n1为二分图的一个子图的顶点数，n2为另一个子图的顶点数，m为边数。</span><br>vector&lt;<span class="hljs-type">int</span>&gt; edge[SIZE]; <span class="hljs-comment">// 这里使用vector存图</span><br><span class="hljs-type">int</span> match[SIZE];        <span class="hljs-comment">// 储存n2中的某个顶点匹配的n1中的顶点</span><br><span class="hljs-type">bool</span> vis[SIZE];         <span class="hljs-comment">// 标记n2中的某个顶点是否已经匹配过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : edge[x]) <span class="hljs-comment">// 遍历所有与x连接的n2内的顶点i</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i]) <span class="hljs-comment">// 如果顶点i本轮还未匹配过</span><br>        &#123;<br>            vis[i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 将其标记</span><br>            <span class="hljs-comment">// 若顶点i还没有匹配到任何n1中顶点，则直接把i与x匹配</span><br>            <span class="hljs-comment">// 如果i已经匹配上，则查询与i匹配的n1中的元素能否换一个匹配，若可以，则将i与x匹配</span><br>            <span class="hljs-keyword">if</span> (match[i] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[i]))<br>            &#123;<br>                match[i] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果没法匹配上，返回false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        edge[u].<span class="hljs-built_in">push_back</span>(v); <span class="hljs-comment">// 只用得到从n1到n2的边，因此只存了单向边</span><br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 匹配的数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) <span class="hljs-comment">// 从n1第一个元素开始，尝试匹配到最后一个元素</span><br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis)); <span class="hljs-comment">// 先清空所有n2的访问情况</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) <span class="hljs-comment">// 如果匹配上则匹配数+1</span><br>            cnt++;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-17-背包模型">2.17 背包模型</h2>
<h3 id="2-17-1-0-1-背包">2.17.1 0/1 背包</h3>
<p>时间复杂度：$O(N\cdot V)$</p>
<p>空间复杂度：$O(N\cdot V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;             <span class="hljs-comment">// N-物品数量 V-背包容积</span><br><span class="hljs-type">int</span> v[SIZE], w[SIZE]; <span class="hljs-comment">// v-体积 w-价值</span><br><span class="hljs-type">int</span> dp[SIZE][SIZE];   <span class="hljs-comment">// 二维动态规划</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[N][V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(N\cdot V)$</p>
<p>空间复杂度：$O(V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;             <span class="hljs-comment">// N-物品数量 V-背包容积</span><br><span class="hljs-type">int</span> v[SIZE], w[SIZE]; <span class="hljs-comment">// v-体积 w-价值</span><br><span class="hljs-type">int</span> dp[SIZE];         <span class="hljs-comment">// 一维动态规划</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-17-2-完全背包">2.17.2 完全背包</h3>
<p>时间复杂度：$O(N\cdot V^2)$ (最坏情况)</p>
<p>空间复杂度：$O(N\cdot V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;<br><span class="hljs-type">int</span> v[SIZE], w[SIZE];<br><span class="hljs-type">int</span> dp[SIZE][SIZE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br>    cout &lt;&lt; dp[N][V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(N\cdot V)$</p>
<p>空间复杂度：$O(N\cdot V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;<br><span class="hljs-type">int</span> v[SIZE], w[SIZE];<br><span class="hljs-type">int</span> dp[SIZE][SIZE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[N][V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(N\cdot V)$</p>
<p>空间复杂度：$O(V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;<br><span class="hljs-type">int</span> v[SIZE], w[SIZE];<br><span class="hljs-type">int</span> dp[SIZE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v[i]; j &lt;= V; j++)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-17-3-多重背包">2.17.3 多重背包</h3>
<p>时间复杂度：$O(N\cdot V^2)$ (最坏情况)</p>
<p>空间复杂度：$O(V)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, V;<br><span class="hljs-type">int</span> v[SIZE], w[SIZE], s[SIZE];<br><span class="hljs-type">int</span> dp[SIZE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k * v[i]] + k * w[i]);<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(N\cdot\log{S}\cdot V)$</p>
<p>空间复杂度：$O(V)$ (已包含空间优化)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE_NlogS = <span class="hljs-number">25000</span>, SIZE_V = <span class="hljs-number">2010</span>; <span class="hljs-comment">// 需要注意各个数组的大小</span><br><span class="hljs-type">int</span> N, V, idx;<br><span class="hljs-type">int</span> v[SIZE_NlogS], w[SIZE_NlogS];<br><span class="hljs-type">int</span> dp[SIZE_V];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V; <span class="hljs-comment">// 物品读入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s) <span class="hljs-comment">// 物品打包</span><br>        &#123;<br>            v[++idx] = a * k;<br>            w[idx] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s)<br>        &#123;<br>            v[++idx] = a * s;<br>            w[idx] = b * s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 01-背包问题</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--)<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：$O(N\cdot V)$</p>
<p>空间复杂度：$O(V)$ (已包含空间优化)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">w</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">s</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">lst</span><span class="hljs-params">(V + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">que</span><span class="hljs-params">(V + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        lst = dp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; v[i]; r++)<br>        &#123;<br>            <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = r; k &lt;= V; k += v[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; que[hh] &lt; k - s[i] * v[i])<br>                    ++hh;<br>                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; lst[que[tt]] - (que[tt] - r) / v[i] * w[i] &lt;= lst[k] - (k - r) / v[i] * w[i])<br>                    --tt;<br>                <span class="hljs-keyword">if</span> (hh &lt;= tt)<br>                    dp[k] = <span class="hljs-built_in">max</span>(dp[k], lst[que[hh]] - (que[hh] - k) / v[i] * w[i]);<br>                que[++tt] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-17-4-分组背包">2.17.4 分组背包</h3>
<p>时间复杂度：$O(V\cdot\sum{S})$</p>
<p>空间复杂度：$O(V)$ (已包含空间优化)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> N, V;<br><span class="hljs-type">int</span> v[SIZE][SIZE], w[SIZE][SIZE], S[SIZE];<br><span class="hljs-type">int</span> dp[SIZE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        cin &gt;&gt; S[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; S[i]; j++)<br>            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j--)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; S[i]; k++)<br>                <span class="hljs-keyword">if</span> (v[i][k] &lt;= j)<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i][k]] + w[i][k]);<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-17-5-混合背包">2.17.5 混合背包</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) <span class="hljs-comment">// 完全背包</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &lt;= V; j++)<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v] + w);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 0-1背包 和 多重背包</span><br>        &#123;<br>            s = <span class="hljs-built_in">abs</span>(s); <span class="hljs-comment">// 一律当多重背包转化成0-1背包</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; vv, ww;<br>            <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt;= s)<br>            &#123;<br>                vv.<span class="hljs-built_in">push_back</span>(v * k);<br>                ww.<span class="hljs-built_in">push_back</span>(w * k);<br>                s -= k;<br>                k *= <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s)<br>            &#123;<br>                vv.<span class="hljs-built_in">push_back</span>(v * s);<br>                ww.<span class="hljs-built_in">push_back</span>(w * s);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; vv.<span class="hljs-built_in">size</span>(); j++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = V; k &gt;= vv[j]; k--)<br>                    dp[k] = <span class="hljs-built_in">max</span>(dp[k], dp[k - vv[j]] + ww[j]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[V] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-18-高精度-Big-Integer">2.18 高精度 Big Integer</h2>
<h3 id="2-18-1-I-O">2.18.1 I/O</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 变量 */</span><br>string a;<br>vector&lt;<span class="hljs-type">int</span>&gt; A;<br><br><span class="hljs-comment">/* 输入 */</span><br>cin &gt;&gt; a; <span class="hljs-comment">// 首先以字符串形式读入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">// 反向将字符串每位写入整型数组，注意减去偏移量‘0’</span><br><br><span class="hljs-comment">/* 输出 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    cout &lt;&lt; A[i]; <span class="hljs-comment">// 反向输出整型数组每一位</span><br></code></pre></td></tr></table></figure>
<h3 id="2-18-2-BI-BI">2.18.2 BI + BI</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (B.<span class="hljs-built_in">size</span>() &gt; A.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>())<br>            t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t = t &gt; <span class="hljs-number">9</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t)<br>        C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-18-3-BI-BI">2.18.3 BI - BI</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>())<br>            t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        t = t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> <span class="hljs-comment">// 若A&gt;=B返回true，否则返回false</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(A, B))<br>        vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">sub</span>(B, A); <span class="hljs-comment">// 这种情况输出时记得先输出一个‘-’符号</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-18-4-BI-I">2.18.4 BI * I</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>())<br>            t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-18-5-BI-I">2.18.5 BI / I</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-19-贝尔曼-福特算法-Bellman-Ford">2.19 贝尔曼-福特算法 Bellman-Ford</h2>
<p>解决赋权图的单源最短路径问题，能解决负边，能解决负环。</p>
<p>时间复杂度：$O(\left|V\right|\cdot\left|E\right|)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">510</span>, MAXM = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> v, e, k;                  <span class="hljs-comment">// v顶点数 e边数 k经过边数限制</span><br><span class="hljs-type">int</span> dist[MAXN], backup[MAXN]; <span class="hljs-comment">// dist最短距离 backup备份上一次迭代</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;              <span class="hljs-comment">// a起点 b终点 w权值  </span><br>&#125; edges[MAXM];                <span class="hljs-comment">// 结构图数组存边</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-built_in">sizeof</span>(dist));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; e; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[v] &gt; INF / <span class="hljs-number">2</span> ? INF : dist[v];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-20-矩阵加速算法">2.20 矩阵加速算法</h2>
<h3 id="2-20-1-n-阶方阵乘法">2.20.1 $n$ 阶方阵乘法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">mat_mul</span>(vector&lt;vector&lt;ll&gt;&gt; a, vector&lt;vector&lt;ll&gt;&gt; b, ll mod)<br>&#123;<br>    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>                res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-20-2-矩阵快速幂">2.20.2 矩阵快速幂</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">mat_pow</span>(vector&lt;vector&lt;ll&gt;&gt; a, ll b, ll mod)<br>&#123;<br>    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        res[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>)<br>            res = <span class="hljs-built_in">mat_mul</span>(res, a, mod);<br>        a = <span class="hljs-built_in">mat_mul</span>(a, a, mod);<br>        b /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-21-最长上升子序列-Longest-Increasing-Subsequence">2.21 最长上升子序列 Longest Increasing Subsequence</h2>
<h3 id="2-21-1-动态规划">2.21.1 动态规划</h3>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> N, a[MAXN];<br><span class="hljs-type">int</span> dp[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    a[<span class="hljs-number">0</span>] = INT32_MIN;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i])<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-21-2-贪心、二分、单调栈">2.21.2 贪心、二分、单调栈</h3>
<p>时间复杂度：$O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> N, a[MAXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; a[i];<br>    v.<span class="hljs-built_in">push_back</span>(a[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; v.<span class="hljs-built_in">back</span>())<br>            v.<span class="hljs-built_in">push_back</span>(a[i]);<br>        <span class="hljs-keyword">else</span><br>            v[<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), a[i]) - v.<span class="hljs-built_in">begin</span>()] = a[i];<br>    &#125;<br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-22-最长公共上升子序列-Longest-Common-Increasing-Subsequence">2.22 最长公共上升子序列 Longest Common Increasing Subsequence</h2>
<h3 id="2-22-1-三重循环-DP">2.22.1 三重循环 DP</h3>
<p>时间复杂度：$O(n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">B</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">10</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N + <span class="hljs-number">10</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; A[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; B[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; j++)<br>        &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-keyword">if</span> (A[i] == B[j])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; j; k++)<br>                    <span class="hljs-keyword">if</span> (B[k] &lt; B[j])<br>                        dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][k] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        ans = <span class="hljs-built_in">max</span>(dp[N][i], ans);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-22-2-将-DP-进行简化">2.22.2 将 DP 进行简化</h3>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">B</span><span class="hljs-params">(N + <span class="hljs-number">10</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">10</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N + <span class="hljs-number">10</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; A[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; B[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; j++)<br>        &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (A[i] == B[j])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], maxv);<br>            <span class="hljs-keyword">if</span> (B[j] &lt; A[i])<br>                maxv = <span class="hljs-built_in">max</span>(maxv, dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        ans = <span class="hljs-built_in">max</span>(dp[N][i], ans);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-23-最近公共祖先-Lowest-Common-Ancestor">2.23 最近公共祖先 Lowest Common Ancestor</h2>
<h3 id="2-23-1-倍增法">2.23.1 倍增法</h3>
<p>预处理：$O(V\log d)$，其中 $d$ 为树的深度。</p>
<p>计算：$O(\log d)$，其中 $d$ 为树的深度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[MAXN], e[MAXN], ne[MAXN], idx;<br><span class="hljs-type">int</span> mylog2[MAXN]; <span class="hljs-comment">// \lfloor log_&#123;2&#125;&#123;x&#125; \rfloor + 1</span><br><span class="hljs-type">int</span> fa[MAXN][<span class="hljs-number">30</span>], dep[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++)<br>        mylog2[i] = mylog2[i - <span class="hljs-number">1</span>] + (<span class="hljs-number">1</span> &lt;&lt; mylog2[i - <span class="hljs-number">1</span>] == i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    fa[now][<span class="hljs-number">0</span>] = father;<br>    dep[now] = dep[father] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mylog2[dep[now]]; i++)<br>        fa[now][i + <span class="hljs-number">1</span>] = fa[fa[now][i]][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[now]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] != father)<br>            <span class="hljs-built_in">dfs</span>(e[i], now);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[a] &lt; dep[b])<br>        <span class="hljs-built_in">swap</span>(a, b); <span class="hljs-comment">// make a &gt;= b</span><br>    <span class="hljs-keyword">while</span> (dep[a] &gt; dep[b])<br>        a = fa[a][mylog2[dep[a] - dep[b]] - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (a == b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mylog2[dep[a]] - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fa[a][i] != fa[b][i])<br>        &#123;<br>            a = fa[a][i];<br>            b = fa[b][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-23-2-树链剖分">2.23.2 树链剖分</h3>
<p>预处理：$O(n)$</p>
<p>计算：$O(\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[u]] &gt; dep[top[v]])<br>            u = fa[top[u]];<br>        <span class="hljs-keyword">else</span><br>            v = fa[top[v]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u] &gt; dep[v] ? v : u;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-24-树链剖分（重链剖分）">2.24 树链剖分（重链剖分）</h2>
<p>链式前向星存图，下标从 $1$ 开始。</p>
<h3 id="2-24-1-剖分">2.24.1 剖分</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span><br><span class="hljs-function"></span>&#123;<br>    son[now] = <span class="hljs-number">-1</span>;<br>    siz[now] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[now]; i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;nxt = e[i];<br>        <span class="hljs-keyword">if</span> (nxt == fa[now])<br>            <span class="hljs-keyword">continue</span>;<br>        fa[nxt] = now;<br>        dep[nxt] = dep[now] + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/* 如果是边权 */</span><br>        <span class="hljs-comment">// val[nxt] = w[i];</span><br>        <span class="hljs-built_in">dfs1</span>(nxt);<br>        siz[now] += siz[nxt];<br>        <span class="hljs-keyword">if</span> (son[now] == <span class="hljs-number">-1</span> || siz[son[now]] &lt; siz[nxt])<br>            son[now] = nxt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> tp)</span></span><br><span class="hljs-function"></span>&#123;<br>    top[now] = tp;<br>    dfn[now] = ++cnt;<br>    rnk[cnt] = now;<br>    <span class="hljs-keyword">if</span> (son[now] == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[now], tp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[now]; i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;nxt = e[i];<br>        <span class="hljs-keyword">if</span> (nxt == son[now] || nxt == fa[now])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(nxt, nxt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-24-2-操作">2.24.2 操作</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_something</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (top[a] != top[b])<br>    &#123;<br>        <span class="hljs-type">int</span> ta = top[a], tb = top[b];<br>        <span class="hljs-keyword">if</span> (dep[ta] &gt;= dep[tb])<br>        &#123;<br>            <span class="hljs-comment">// do something in range [dfn[ta], dfn[a]]</span><br>            a = fa[ta];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// do something in range [dfn[tb], dfn[b]]</span><br>            b = fa[tb];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[a] &gt; dep[b])<br>        <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-comment">// do something in range [dfn[a], dfn[b]]     如果是点权</span><br>    <span class="hljs-comment">// do something in range [dfn[a] + 1, dfn[b]] 如果是边权</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-25-字符串哈希">2.25 字符串哈希</h2>
<h3 id="2-25-1-哈希">2.25.1 哈希</h3>
<ul>
<li>$p=131,13331,233,449$</li>
<li>$m=10^9+7,998244353,998244853,436522843,2^{64}$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> ll P = <span class="hljs-number">449</span>, MOD = <span class="hljs-number">436522843</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">get_hash</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        res = (res * P % MOD + s[i]) % MOD;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-25-2-子串哈希">2.25.2 子串哈希</h3>
<p>预处理：$O(n)$</p>
<p>计算：$O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StrHash</span><br>&#123;<br>    <span class="hljs-type">int</span> len, base, mod;<br>    vector&lt;<span class="hljs-type">int</span>&gt; p, h;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">int</span> base, <span class="hljs-type">int</span> mod)</span></span><br><span class="hljs-function">    </span>&#123;<br>        len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;base = base;<br>        <span class="hljs-keyword">this</span>-&gt;mod = mod;<br>        p.<span class="hljs-built_in">resize</span>(len + <span class="hljs-number">1</span>);<br>        h.<span class="hljs-built_in">resize</span>(len + <span class="hljs-number">1</span>);<br>        p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++)<br>            p[i] = p[i - <span class="hljs-number">1</span>] * base % mod;<br>        h[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] % mod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>            h[i] = (h[i - <span class="hljs-number">1</span>] * base % mod + s[i]) % mod;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> h[r];<br>        <span class="hljs-keyword">return</span> (h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>] % mod + mod) % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-25-3-允许-k-次失配的匹配">2.25.3 允许 $k$ 次失配的匹配</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 依赖上文的StrHash结构体 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(StrHash &amp;a, StrHash &amp;b, <span class="hljs-type">int</span> toler)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.len &lt; b.len) <span class="hljs-comment">// make a &gt;= b</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(b, a, toler);<br>    <span class="hljs-type">int</span> la = a.len, lb = b.len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= la - lb; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (err &lt;= toler &amp;&amp; pos &lt; lb)<br>        &#123;<br>            <span class="hljs-type">int</span> l = pos, r = lb - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">get</span>(i + pos, i + mid) == b.<span class="hljs-built_in">get</span>(pos, mid))<br>                    l = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    r = mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">get</span>(i + pos, i + l) != b.<span class="hljs-built_in">get</span>(pos, l))<br>                err++;<br>            pos = l + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (err &lt;= toler)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-26-Manacher-算法">2.26 Manacher 算法</h2>
<h3 id="2-26-1-预处理">2.26.1 预处理</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">pre_process</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    string ans = <span class="hljs-string">&quot;^&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s)<br>    &#123;<br>        ans += <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans += c;<br>    &#125;<br>    ans += <span class="hljs-string">&#x27;#&#x27;</span>;<br>    ans += <span class="hljs-string">&#x27;$&#x27;</span>;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-26-2-马拉车">2.26.2 马拉车</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s - 字符串（下标1开始，需要预处理）</span><br><span class="hljs-comment">// p - 对应位置回文半径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">(string &amp;s, vector&lt;<span class="hljs-type">int</span>&gt; &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        p[i] = r &gt; i ? <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * mid - i], r - i) : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (s[i + p[i]] == s[i - p[i]])<br>            p[i]++;<br>        <span class="hljs-keyword">if</span> (i + p[i] &gt; r)<br>        &#123;<br>            r = i + p[i];<br>            mid = i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-27-拓扑排序-Topo-Sort">2.27 拓扑排序 Topo Sort</h2>
<p>时间复杂度：$O(V+E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">5050</span>;<br><span class="hljs-type">int</span> h[MAXN], e[MAXN], d[MAXN], ne[MAXN], idx;<br><span class="hljs-type">int</span> que[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    idx++;<br>    d[b]++;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topo_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// n - vertice cnt</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            que[++tt] = i;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;now = que[hh++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[now]; i; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> &amp;nxt = e[i];<br>            d[nxt]--;<br>            <span class="hljs-keyword">if</span> (!d[nxt])<br>                que[++tt] = nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>; <span class="hljs-comment">// false if illegal</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-28-莫队-Mo’s-Algorithm">2.28 莫队 Mo’s Algorithm</h2>
<p>若存在一个长度为 $n$ 的序列，对于序列上的 $m$ 个区间询问问题，如果一个区间答案能够在 $O(1)$ 转移到相邻区间的答案，那么可以通过莫队算法在 $O(n\sqrt m)$ 的复杂度求出所有询问。</p>
<h3 id="2-28-1-普通莫队">2.28.1 普通莫队</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cur_ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// current answer</span><br><span class="hljs-type">int</span> block;       <span class="hljs-comment">// block size</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123; <span class="hljs-comment">/* update current answer */</span> &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123; <span class="hljs-comment">/* update current answer */</span> &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Query a, Query b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.l / block != b.l / block)<br>        <span class="hljs-keyword">return</span> a.l &lt; b.l;<br>    <span class="hljs-keyword">return</span> (a.l / block) % <span class="hljs-number">2</span> ? a.r &lt; b.r : a.r &gt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    block = <span class="hljs-built_in">sqrt</span>(m);<br>    <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>(), query.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; <span class="hljs-comment">// initial</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (l &gt; query[i].l) <span class="hljs-built_in">add</span>(--l);<br>        <span class="hljs-keyword">while</span> (r &lt; query[i].r) <span class="hljs-built_in">add</span>(++r);<br>        <span class="hljs-keyword">while</span> (l &lt; query[i].l) <span class="hljs-built_in">del</span>(l++);<br>        <span class="hljs-keyword">while</span> (r &gt; query[i].r) <span class="hljs-built_in">del</span>(r--);   <br>        ans[query[i].idx] = cur_ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-28-2-带修改莫队">2.28.2 带修改莫队</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span><br>&#123;<br>    <span class="hljs-type">int</span> idx, l, r, ver;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Query b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (l / block != b.l / block)<br>            <span class="hljs-keyword">return</span> l &lt; b.l;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r / block != b.r / block)<br>            <span class="hljs-keyword">return</span> r &lt; b.r;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> ver &lt; b.ver;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Modif</span><br>&#123;<br>    <span class="hljs-type">int</span> pos, color;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= now_idx; i++)<br>&#123;<br>    <span class="hljs-keyword">while</span> (l &gt; qu[i].l) <span class="hljs-built_in">add</span>(c[--l]);<br>    <span class="hljs-keyword">while</span> (r &lt; qu[i].r) <span class="hljs-built_in">add</span>(c[++r]);<br>    <span class="hljs-keyword">while</span> (l &lt; qu[i].l) <span class="hljs-built_in">del</span>(c[l++]);<br>    <span class="hljs-keyword">while</span> (r &gt; qu[i].r) <span class="hljs-built_in">del</span>(c[r--]);<br>    <span class="hljs-keyword">while</span> (time &lt; qu[i].ver)<br>    &#123;<br>        time++;<br>        <span class="hljs-keyword">if</span> (l &lt;= mo[time].pos &amp;&amp; mo[time].pos &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">add</span>(mo[time].color);<br>            <span class="hljs-built_in">del</span>(c[mo[time].pos]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(mo[time].color, c[mo[time].pos]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (time &gt; qu[i].ver)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= mo[time].pos &amp;&amp; mo[time].pos &lt;= r)<br>        &#123;<br>            <span class="hljs-built_in">add</span>(mo[time].color);<br>            <span class="hljs-built_in">del</span>(c[mo[time].pos]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(mo[time].color, c[mo[time].pos]);<br>        time--;<br>    &#125;<br>    ans[qu[i].idx] = cur;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>3 数据结构 Data Structure</h1>
<h2 id="3-1-单调队列-Monotonic-Queue">3.1 单调队列 Monotonic Queue</h2>
<p>时间复杂度：$O(n)$</p>
<h3 id="3-1-1-STL-队列">3.1.1 STL 队列</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// val[ ]: 储存数据的数组</span><br><span class="hljs-comment">// n: 需要计算的范围</span><br><span class="hljs-comment">// k: 给定的区间大小</span><br><span class="hljs-comment">// q: STL双向队列，储存val[ ]中元素的数组序号</span><br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; val[q.<span class="hljs-built_in">back</span>()] &gt; val[i]) <span class="hljs-comment">// 去尾操作</span><br>        q.<span class="hljs-built_in">pop_back</span>();<br>    q.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 新元素（的序号）入队</span><br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-comment">// 判断是否需要进行下面两个操作</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">front</span>() &lt; i - k + <span class="hljs-number">1</span>) <span class="hljs-comment">// 删头操作</span><br>            q.<span class="hljs-built_in">pop_front</span>();<br>        cout &lt;&lt; val[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 输出操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-1-2-数组队列">3.1.2 数组队列</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// val[ ]: 储存数据的数组</span><br><span class="hljs-comment">// n: 需要计算的范围</span><br><span class="hljs-comment">// k: 给定的区间大小</span><br><span class="hljs-comment">// q: 数组队列，储存val[ ]中元素的数组序号</span><br><span class="hljs-comment">// h, t: 队头、队尾指针，(0, -1)为空</span><br><span class="hljs-type">int</span> q[MAXN], h = <span class="hljs-number">0</span>, t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-keyword">while</span> (h &lt;= t &amp;&amp; val[q[t]] &gt; val[i])<br>        t--;<br>    q[++t] = i;<br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[h] &lt; i - k + <span class="hljs-number">1</span>)<br>            h++;<br>        cout &lt;&lt; val[q[h]] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-2-并查集-Disjoint-Set-Union">3.2 并查集 Disjoint Set Union</h2>
<h3 id="3-2-1-朴素">3.2.1 朴素</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 朴素版并查集（不推荐使用）</span><br><span class="hljs-type">int</span> fa[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-2-路径压缩">3.2.2 路径压缩</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 路径压缩版并查集（最常使用）</span><br><span class="hljs-type">int</span> fa[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="hljs-built_in">find</span>(fa[x])); <span class="hljs-comment">// 注1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    fa[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-3-启发式合并（按秩）">3.2.3 启发式合并（按秩）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fa[MAXN], rnk[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        fa[i] = i;<br>        rnk[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="hljs-built_in">find</span>(fa[x]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(i), y = <span class="hljs-built_in">find</span>(j);<br>    <span class="hljs-keyword">if</span> (x == y)<br>    	<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (rnk[x] &lt; rnk[y])<br>        <span class="hljs-built_in">swap</span>(x, y);<br>    fa[y] = x;<br>    <span class="hljs-keyword">if</span> (rnk[x] == rnk[y])<br>        rnk[x]++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-4-启发式合并（按节点数）">3.2.4 启发式合并（按节点数）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fa[MAXN], sz[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        fa[i] = i;<br>        sz[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="hljs-built_in">find</span>(fa[x]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(i), y = <span class="hljs-built_in">find</span>(j);<br>    <span class="hljs-keyword">if</span> (x == y)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (sz[x] &lt; sz[y])<br>        <span class="hljs-built_in">swap</span>(x, y);<br>    fa[y] = x;<br>    sz[x] += sz[y];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-5-到根节点的距离">3.2.5 到根节点的距离</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fa[MAXN], ds[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (fa[n] == n)<br>        <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">find</span>(fa[n]); <span class="hljs-comment">// 先路径压缩</span><br>    ds[n] += ds[fa[n]];    <span class="hljs-comment">// 再更新距离</span><br>    <span class="hljs-keyword">return</span> fa[n] = res;    <span class="hljs-comment">// 再路径压缩</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">// r为两节点的距离关系</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> faa = <span class="hljs-built_in">find</span>(a), fab = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 一定要先储存好父节点，否则下面更新后会变化。</span><br>    fa[faa] = fab;<br>    ds[faa] = ds[b] - ds[a] + r;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-3-链式前向星">3.3 链式前向星</h2>
<h3 id="3-3-1-数组，下标从-0">3.3.1 数组，下标从 0</h3>
<p>h 初始化为 -1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[MAXN], e[MAXN], ne[MAXN], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; ~i; i = ne[i])<br>&#123;<br>    <span class="hljs-type">int</span> &amp;cur = e[i];<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-2-数组，下标从-1">3.3.2 数组，下标从 1</h3>
<p>h 初始化为 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[MAXN], e[MAXN], ne[MAXN], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    idx++;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i; i = ne[i])<br>&#123;<br>    <span class="hljs-type">int</span> &amp;cur = e[i];<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-3-结构体">3.3.3 结构体</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EDGE</span><br>&#123;<br>    <span class="hljs-type">int</span> to, weight, next;<br>&#125; edge[SIZE];<br><span class="hljs-type">int</span> head[SIZE];<br><br><span class="hljs-type">int</span> V, E; <span class="hljs-comment">// E边数，V顶点数</span><br><span class="hljs-type">int</span> cnt;  <span class="hljs-comment">// 储存边时的下标</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 全部初始化为-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++)<br>        head[i] = <span class="hljs-number">-1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> weight)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[cnt].to = end;           <span class="hljs-comment">// 终点</span><br>    edge[cnt].weight = weight;    <span class="hljs-comment">// 长度</span><br>    edge[cnt].next = head[start]; <span class="hljs-comment">// 下一条边</span><br>    head[start] = cnt++;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i != <span class="hljs-number">-1</span>; i = edge[j].next)<br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-4-树状数组-Fenwick-Tree">3.4 树状数组 Fenwick Tree</h2>
<p>时间复杂度：$O(\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> Fenwick_Tree[MAXN];<br><span class="hljs-comment">// 如果不是全局变量记得初始化为0</span><br><br><span class="hljs-comment">// 查询(0,pos]的区间和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i; i -= i &amp; -i)<br>        ans += Fenwick_Tree[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 查询[l,r]的区间和</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(r) - <span class="hljs-built_in">query</span>(l - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 第pos位加上val</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; MAXN; i += i &amp; -i)<br>        Fenwick_Tree[i] += val;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-5-字典树-Trie">3.5 字典树 Trie</h2>
<p>时间复杂度：$O(m)$. $m$ 为待操作字符串的长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> son[MAXN][<span class="hljs-number">26</span>], cnt[MAXN], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c])<br>            son[p][c] = ++idx;<br>        p = son[p][c];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-6-堆-Heap">3.6 堆 Heap</h2>
<h3 id="3-6-1-上下滤">3.6.1 上下滤</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">// 堆的最大大小</span><br><span class="hljs-type">int</span> heap[MAXN];            <span class="hljs-comment">// 储存堆的数组</span><br><span class="hljs-type">int</span> idx;                   <span class="hljs-comment">// 堆的当前大小</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; heap[u] &lt; heap[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(heap[u], heap[u / <span class="hljs-number">2</span>]);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= idx &amp;&amp; heap[u * <span class="hljs-number">2</span>] &lt; heap[t])<br>        t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= idx &amp;&amp; heap[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; heap[t])<br>        t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (t != u)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(heap[t], heap[u]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-6-2-建堆">3.6.2 建堆</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure>
<h3 id="3-6-3-取得堆中最小值">3.6.3 取得堆中最小值</h3>
<p>堆顶即为最小值。</p>
<h3 id="3-6-4-插入">3.6.4 插入</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// num 为待插入的数</span><br>heap[++idx] = num;<br><span class="hljs-built_in">up</span>(idx);<br></code></pre></td></tr></table></figure>
<h3 id="3-6-5-删除">3.6.5 删除</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// id 为待删除节点的编号</span><br>heap[id] = heap[idx--];<br><span class="hljs-built_in">up</span>(id);<br><span class="hljs-built_in">down</span>(id);<br></code></pre></td></tr></table></figure>
<h3 id="3-6-6-修改">3.6.6 修改</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// id 为待修改节点的编号，num 为新数值</span><br>heap[id] = num;<br><span class="hljs-built_in">up</span>(id);<br><span class="hljs-built_in">down</span>(id);<br></code></pre></td></tr></table></figure>
<h3 id="3-6-7-带映射关系的堆">3.6.7 带映射关系的堆</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意该函数的形参 a, b 是下标，和内置的 swap 函数不同。</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(heap[a], heap[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    idx++; <br>    id++;<br>    heap[idx] = num;<br>    ph[id] = idx;    <span class="hljs-comment">// 建立插入序号-&gt;节点编号的映射</span><br>    hp[idx] = id;    <span class="hljs-comment">// 建立节点编号-&gt;插入序号的映射</span><br>    <span class="hljs-built_in">up</span>(idx);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>, idx); <span class="hljs-comment">// 用heap_swap而不是直接赋值，才能维护映射关系</span><br>    idx--;<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = ph[id];    <span class="hljs-comment">// 需要先储存k，防止操作过程中变化</span><br>    <span class="hljs-built_in">heap_swap</span>(k, idx); <span class="hljs-comment">// 用heap_swap而不是直接赋值，才能维护映射关系</span><br>    idx--;<br>    <span class="hljs-built_in">up</span>(k);<br>    <span class="hljs-built_in">down</span>(k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = ph[id]; <span class="hljs-comment">// 需要先储存k，防止操作过程中变化</span><br>    heap[k] = num;<br>    <span class="hljs-built_in">up</span>(k);<br>    <span class="hljs-built_in">down</span>(k);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-7-哈希表-Hash-Table">3.7 哈希表 Hash Table</h2>
<h3 id="3-7-1-开放寻址法-Open-Addressing">3.7.1 开放寻址法 Open Addressing</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 开放寻址法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">200003</span>, NONE = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">// SIZE为取模的数，同时也是数组大小，NONE为定义的代表空位的数字，需要不在哈希函数值域内</span><br><span class="hljs-type">int</span> hs[SIZE];<br><span class="hljs-comment">// hs哈希表 !!!hs每一字节需初始化为0x3f!!!</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 哈希函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x % SIZE + SIZE) % SIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 若x在表内，返回x的位置；若x不在表内，返回x应当插入的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = <span class="hljs-built_in">f</span>(x);<br>    <span class="hljs-keyword">while</span> (hs[y] != NONE &amp;&amp; hs[y] != x) <span class="hljs-comment">// 当找到空位或找到了x就停下来</span><br>    &#123;<br>        <span class="hljs-comment">// 找不到就一直找下一位，找到最后一位再从第0位开始找</span><br>        y++;<br>        <span class="hljs-keyword">if</span> (y == SIZE)<br>            y = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 将x插入表内</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br>    hs[k] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 查询x是否在表内</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">return</span> hs[k] == x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-7-2-单独链表法-Separate-Chaining">3.7.2 单独链表法 Separate Chaining</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 单独链表法 使用数组模拟链表实现 */</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">100003</span>;<br><span class="hljs-comment">// SIZE为取模的数，同时也是数组大小</span><br><span class="hljs-type">int</span> hs[SIZE], val[SIZE], nxt[SIZE], idx;<br><span class="hljs-comment">// hs哈希表储存链表头指针，val链表节点数据域，nxt链表节点指针域，idx链表长度</span><br><span class="hljs-comment">// !!!hs每一字节需初始化为-1!!!</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 哈希函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x % SIZE + SIZE) % SIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 将x插入表内</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = <span class="hljs-built_in">f</span>(x);<br>    <span class="hljs-comment">// 下面的操作为链表头插法</span><br>    val[idx] = x;<br>    nxt[idx] = hs[y];<br>    hs[y] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 查询x是否在表内</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = <span class="hljs-built_in">f</span>(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = hs[y]; i != <span class="hljs-number">-1</span>; i = nxt[i]) <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">if</span> (val[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-8-ST-表-Sparse-Table">3.8 ST 表 Sparse Table</h2>
<p>在 $O(n\log n)$ 完成初始化，在 $O(1)$ 回答每个区间查询。不支持修改数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        cin &gt;&gt; f[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= LOGN; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= N - (<span class="hljs-number">1</span> &lt;&lt; i) + <span class="hljs-number">1</span>; j++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> pow = <span class="hljs-number">0</span>, pow2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (pow2 * <span class="hljs-number">2</span> &lt;= len)<br>    &#123;<br>        pow++;<br>        pow2 *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[pow][l], f[pow][r - pow2 + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-9-线段树-Segment-Tree">3.9 线段树 Segment Tree</h2>
<h3 id="3-9-1-区间和；区间加">3.9.1 区间和；区间加</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 线段树: 维护区间和, 支持区间加, 使用懒惰标记 */</span><br><span class="hljs-comment">/* 下标从1开始，注意空间大小 */</span><br><span class="hljs-keyword">namespace</span> segtree<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">int</span> arr[MAXN], sum[MAXN]; <span class="hljs-comment">// 原数组, 线段树区间和</span><br>    <span class="hljs-type">int</span> addv[MAXN];           <span class="hljs-comment">// 加法实际值（同时做加法标记）</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (addv[p] &amp;&amp; s != t)<br>        &#123;<br>            <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>            sum[p * <span class="hljs-number">2</span>] += addv[p] * (m - s + <span class="hljs-number">1</span>);<br>            sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += addv[p] * (t - m);<br>            addv[p * <span class="hljs-number">2</span>] += addv[p];<br>            addv[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += addv[p];<br>            addv[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        sum[p] = sum[p * <span class="hljs-number">2</span>] + sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            sum[p] = arr[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, <span class="hljs-number">2</span> * p);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] += c</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>        &#123;<br>            sum[p] += (t - s + <span class="hljs-number">1</span>) * c;<br>            addv[p] += c;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">add</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">add</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] ?sum</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>            <span class="hljs-keyword">return</span> sum[p];<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            sum += <span class="hljs-built_in">query</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            sum += <span class="hljs-built_in">query</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-9-2-区间和；区间修改">3.9.2 区间和；区间修改</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 线段树: 维护区间和, 支持区间修改, 使用懒惰标记 */</span><br><span class="hljs-comment">/* 下标从1开始，注意空间大小 */</span><br><span class="hljs-keyword">namespace</span> segtree<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> arr[MAXN], sum[MAXN]; <span class="hljs-comment">// 原数组, 线段树区间和</span><br>    <span class="hljs-type">int</span> updv[MAXN];           <span class="hljs-comment">// 修改值</span><br>    <span class="hljs-type">bool</span> updt[MAXN];          <span class="hljs-comment">// 修改标记</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (updt[p] &amp;&amp; s != t)<br>        &#123;<br>            <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>            sum[p * <span class="hljs-number">2</span>] = updv[p] * (m - s + <span class="hljs-number">1</span>);<br>            sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = updv[p] * (t - m);<br>            updv[p * <span class="hljs-number">2</span>] = updv[p];<br>            updv[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = updv[p];<br>            updt[p * <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            updt[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            updt[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        sum[p] = sum[p * <span class="hljs-number">2</span>] + sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            sum[p] = arr[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, <span class="hljs-number">2</span> * p);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] = c</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>        &#123;<br>            sum[p] = (t - s + <span class="hljs-number">1</span>) * c;<br>            updt[p] = <span class="hljs-number">1</span>;<br>            updv[p] = c;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] ?sum</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>            <span class="hljs-keyword">return</span> sum[p];<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-9-3-区间和；区间加、区间乘">3.9.3 区间和；区间加、区间乘</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 线段树: 维护区间和, 支持区间加与乘, 使用懒惰标记 */</span><br><span class="hljs-comment">/* 下标从1开始，注意空间大小 */</span><br><span class="hljs-keyword">namespace</span> segtree<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> arr[MAXN], sum[MAXN];   <span class="hljs-comment">// 原数组, 线段树区间和</span><br>    <span class="hljs-type">int</span> addv[MAXN], mulv[MAXN]; <span class="hljs-comment">// 加法值, 乘法值（同时做标记）</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mulv[p] != <span class="hljs-number">1</span> &amp;&amp; s != t)<br>        &#123;<br>            sum[p * <span class="hljs-number">2</span>] *= mulv[p];<br>            sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] *= mulv[p];<br>            addv[p * <span class="hljs-number">2</span>] *= mulv[p];<br>            addv[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] *= mulv[p];<br>            mulv[p * <span class="hljs-number">2</span>] *= mulv[p];<br>            mulv[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] *= mulv[p];<br>            mulv[p] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (addv[p] != <span class="hljs-number">0</span> &amp;&amp; s != t)<br>        &#123;<br>            sum[p * <span class="hljs-number">2</span>] += addv[p] * (m - s + <span class="hljs-number">1</span>);<br>            sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += addv[p] * (t - m);<br>            addv[p * <span class="hljs-number">2</span>] += addv[p];<br>            addv[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += addv[p];<br>            addv[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        sum[p] = sum[p * <span class="hljs-number">2</span>] + sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mulv[p] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            sum[p] = arr[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, <span class="hljs-number">2</span> * p);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] += c</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>        &#123;<br>            sum[p] += (t - s + <span class="hljs-number">1</span>) * c;<br>            addv[p] += c;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">add</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">add</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] *= c</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>        &#123;<br>            sum[p] *= c;<br>            addv[p] *= c;<br>            mulv[p] *= c;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">mul</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">mul</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> <span class="hljs-comment">// [l, r] ?sum</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>            <span class="hljs-keyword">return</span> sum[p];<br>        <span class="hljs-built_in">push_down</span>(s, t, p);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-9-4-权值线段树">3.9.4 权值线段树</h3>
<p>第 $k$ 小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 权值线段树 */</span><br><span class="hljs-keyword">namespace</span> segtree<br>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">int</span> sum[MAXN]; <span class="hljs-comment">// 数的个数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            sum[p] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, <span class="hljs-number">2</span> * p);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        sum[p]++;<br>        <span class="hljs-keyword">if</span> (s == t)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= m)<br>            <span class="hljs-built_in">update</span>(x, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">update</span>(x, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>            <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (sum[p * <span class="hljs-number">2</span>] &gt;= k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(k, s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(k - sum[p * <span class="hljs-number">2</span>], m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="3-10-可持久化线段树-Persistent-Segment-Tree">3.10 可持久化线段树 Persistent Segment Tree</h2>
<h3 id="3-10-1-单点修改">3.10.1 单点修改</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> pst<br>&#123;<br>    <span class="hljs-comment">/* ### array index must start from ONE ### */</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> root[MAXN];<br>    <span class="hljs-type">int</span> val[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], lson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], rson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], cur_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = ++cur_idx;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            val[now] = arr[s];<br>            <span class="hljs-keyword">return</span> now;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        lson[now] = <span class="hljs-built_in">build</span>(arr, s, m);<br>        rson[now] = <span class="hljs-built_in">build</span>(arr, m + <span class="hljs-number">1</span>, t);<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clone_node</span><span class="hljs-params">(<span class="hljs-type">int</span> orig)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ++cur_idx;<br>        val[cur_idx] = val[orig];<br>        lson[cur_idx] = lson[orig];<br>        rson[cur_idx] = rson[orig];<br>        <span class="hljs-keyword">return</span> cur_idx;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-built_in">clone_node</span>(p);<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            val[now] = c;<br>            <span class="hljs-keyword">return</span> now;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= m)<br>            lson[now] = <span class="hljs-built_in">update</span>(x, c, s, m, lson[now]);<br>        <span class="hljs-keyword">else</span><br>            rson[now] = <span class="hljs-built_in">update</span>(x, c, m + <span class="hljs-number">1</span>, t, rson[now]);<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>            <span class="hljs-keyword">return</span> val[p];<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, s, m, lson[p]);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, m + <span class="hljs-number">1</span>, t, rson[p]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-10-2-区间修改">3.10.2 区间修改</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> pst<br>&#123;<br>    <span class="hljs-comment">/* ### array index must start from ONE ### */</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">signed</span> root[MAXN];<br>    <span class="hljs-type">int</span> cur_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> val[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], mark[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>];<br>    <span class="hljs-type">signed</span> lson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], rson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = ++cur_idx;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            val[now] = arr[s];<br>            <span class="hljs-keyword">return</span> now;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        lson[now] = <span class="hljs-built_in">build</span>(arr, s, m);<br>        rson[now] = <span class="hljs-built_in">build</span>(arr, m + <span class="hljs-number">1</span>, t);<br>        val[now] = val[lson[now]] + val[rson[now]];<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clone_node</span><span class="hljs-params">(<span class="hljs-type">int</span> orig)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ++cur_idx;<br>        val[cur_idx] = val[orig];<br>        mark[cur_idx] = mark[orig];<br>        lson[cur_idx] = lson[orig];<br>        rson[cur_idx] = rson[orig];<br>        <span class="hljs-keyword">return</span> cur_idx;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-built_in">clone_node</span>(p);<br>        val[now] += (<span class="hljs-built_in">min</span>(r, t) - <span class="hljs-built_in">max</span>(l, s) + <span class="hljs-number">1</span>) * c;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>        &#123;<br>            mark[now] += c;<br>            <span class="hljs-keyword">return</span> now;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            lson[now] = <span class="hljs-built_in">update</span>(l, r, c, s, m, lson[now]);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            rson[now] = <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, rson[now]);<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> mk = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>            <span class="hljs-keyword">return</span> val[p] + mk * (t - s + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, s, m, lson[p], mk + mark[p]);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            ans += <span class="hljs-built_in">query</span>(l, r, m + <span class="hljs-number">1</span>, t, rson[p], mk + mark[p]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-10-3-可持久化权值线段树（主席树）">3.10.3 可持久化权值线段树（主席树）</h3>
<p>区间第 $k$ 小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> hjt<br>&#123;<br>    <span class="hljs-comment">/* ### array index must start from ONE ### */</span><br><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> sum[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], lson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], rson[(MAXN &lt;&lt; <span class="hljs-number">5</span>) + <span class="hljs-number">10</span>], cur_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> root[MAXN], cur_ver = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = ++cur_idx;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            sum[now] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> now;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        lson[now] = <span class="hljs-built_in">build</span>(s, m);<br>        rson[now] = <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t);<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clone_node</span><span class="hljs-params">(<span class="hljs-type">int</span> orig)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ++cur_idx;<br>        sum[cur_idx] = sum[orig] + <span class="hljs-number">1</span>;<br>        lson[cur_idx] = lson[orig];<br>        rson[cur_idx] = rson[orig];<br>        <span class="hljs-keyword">return</span> cur_idx;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-built_in">clone_node</span>(p);<br>        <span class="hljs-keyword">if</span> (s == t)<br>            <span class="hljs-keyword">return</span> now;<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= m)<br>            lson[now] = <span class="hljs-built_in">update</span>(x, s, m, lson[now]);<br>        <span class="hljs-keyword">else</span><br>            rson[now] = <span class="hljs-built_in">update</span>(x, m + <span class="hljs-number">1</span>, t, rson[now]);<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>            <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> delt = sum[lson[r]] - sum[lson[l]];<br>        <span class="hljs-type">int</span> m = (s + t) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= delt)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, lson[l], lson[r], s, m);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x - delt, rson[l], rson[r], m + <span class="hljs-number">1</span>, t);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">auto</span> b = a;<br>    <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-type">int</span> uni = <span class="hljs-built_in">unique</span>(b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + n) - b.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<br>    hjt::root[<span class="hljs-number">0</span>] = hjt::<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, uni);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + uni, a[i]) - b.<span class="hljs-built_in">begin</span>();<br>        hjt::root[i] = hjt::<span class="hljs-built_in">update</span>(t, <span class="hljs-number">1</span>, m, hjt::root[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r, k;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;<br>        <span class="hljs-type">int</span> t = hjt::<span class="hljs-built_in">query</span>(k, hjt::root[l - <span class="hljs-number">1</span>], hjt::root[r], <span class="hljs-number">1</span>, m);<br>        cout &lt;&lt; b[t] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-11-归并树-MergeSortTree">3.11 归并树 MergeSortTree</h2>
<ul>
<li>查找区间 $[l,r]$ 内的大小范围在 $[a,b]$ 的数的个数（类似条件均可查找）</li>
<li>查找区间 $[l,r]$ 内第 $k$ 大的数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MergeSortTree</span><br>&#123;<br>    <span class="hljs-comment">/* ### array index must start from ONE ### */</span><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; tree;<br><br>    <span class="hljs-comment">// arr: ori arr, [s, t]: cur seg, x: cur node</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            tree[x] = &#123;arr[s]&#125;;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = s + (t - s) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(arr, s, m, <span class="hljs-number">2</span> * x);<br>        <span class="hljs-built_in">build</span>(arr, m + <span class="hljs-number">1</span>, t, <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">merge</span>(tree[<span class="hljs-number">2</span> * x].<span class="hljs-built_in">begin</span>(), tree[<span class="hljs-number">2</span> * x].<span class="hljs-built_in">end</span>(),<br>              tree[<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), tree[<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(),<br>              <span class="hljs-built_in">back_inserter</span>(tree[x]));<br>    &#125;<br><br>    <span class="hljs-built_in">MergeSortTree</span>(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) : <span class="hljs-built_in">n</span>(arr.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> sz = <span class="hljs-number">1</span> &lt;&lt; (__lg(n) + <span class="hljs-built_in">bool</span>(__builtin_popcount(n) - <span class="hljs-number">1</span>)); <span class="hljs-comment">// sz = \lceil \log_&#123;2&#125;&#123;n&#125; \rceil</span><br>        tree.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * sz);<br>        <span class="hljs-built_in">build</span>(arr, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// [l, r]: query array interval, [mn, mx]: query value interval, [s, t]: cur seg, x: cur node</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> mn, <span class="hljs-type">int</span> mx, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">upper_bound</span>(tree[x].<span class="hljs-built_in">begin</span>(), tree[x].<span class="hljs-built_in">end</span>(), mx) - <span class="hljs-built_in">lower_bound</span>(tree[x].<span class="hljs-built_in">begin</span>(), tree[x].<span class="hljs-built_in">end</span>(), mn);<br>        <span class="hljs-type">int</span> m = s + (t - s) / <span class="hljs-number">2</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            ans += <span class="hljs-built_in">count</span>(l, r, mn, mx, s, m, x * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            ans += <span class="hljs-built_in">count</span>(l, r, mn, mx, m + <span class="hljs-number">1</span>, t, x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// query number of elements in the [l, r] interval that fall within the range [mn, mx]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> mn, <span class="hljs-type">int</span> mx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(l, r, mn, mx, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// find the kth smallest number in the [l, r] interval</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pl = <span class="hljs-number">1</span>, pr = n;<br>        <span class="hljs-keyword">while</span> (pl &lt; pr)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (pl + pr) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span>(l, r, INT32_MIN, tree[<span class="hljs-number">1</span>][mid]) &lt; k)<br>                pl = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                pr = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tree[<span class="hljs-number">1</span>][pl];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1>4 数论 Number theory</h1>
<h2 id="4-1-模逆元">4.1 模逆元</h2>
<p>$ab\equiv1\pmod p$，知 $a,p$ 求 $b$.</p>
<ul>
<li>$a,p$ 不互质：不存在逆元</li>
<li>$a,p$ 互质
<ul>
<li>$p$ 为质数：费马小定理 $b=a^{p-2}\pmod p$，用快速幂算。</li>
<li>$p$ 为合数：扩展欧几里得算法求逆元。<strong>（千万不可直接快速幂）</strong></li>
</ul>
</li>
</ul>
<h2 id="4-2-算术基本定理-Fundamental-theorem-of-arithmetic">4.2 算术基本定理 Fundamental theorem of arithmetic</h2>
<p>定理：任何一个大于 $1$ 的自然数 $N$，如果 $N$ 不为质数，那么 $N$ 可以唯一分解成有限个质数的乘积 $N=P_1^{a_1}P_2^{a_2}P_3^{a_3}\cdots P_n^{a_n}$，$P_1&lt;P_2&lt;P_3&lt;\cdots&lt;P_n$ 且均为质数，$a_1,a_2,a_3,\cdots,a_n$ 均为正整数。</p>
<p>推论：一个大于 $1$ 的整数 $N$，如果它的标准分解式为 $N=P_1^{a_1}P_2^{a_2}P_3^{a_3}\cdots P_n^{a_n}$，那么它的正因数个数为 $\sigma_0(N)=(1+a_1)(1+a_2)\cdots(1+a_n)$</p>
<h3 id="4-2-1-求正因数个数">4.2.1 求正因数个数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> is_prime[SIZE];<br><span class="hljs-type">int</span> prime[SIZE], primesize = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 欧拉筛生成质数代码省略</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> now = n, ans = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; primesize &amp;&amp; prime[i] &lt;= <span class="hljs-built_in">sqrt</span>(now); i++)<br>	&#123;<br>		<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (now % prime[i] == <span class="hljs-number">0</span>)<br>		&#123;<br>			cnt++;<br>			now /= prime[i];<br>		&#125;<br>		ans *= (cnt + <span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (now != <span class="hljs-number">1</span>)<br>		ans *= <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-2-判断正因数之和奇偶性">4.2.2 判断正因数之和奇偶性</h3>
<p>需要以下结论：</p>
<ul>
<li>奇数个奇数相加为奇数，偶数个奇数相加为偶数</li>
<li>奇数乘奇数为奇数，奇数乘偶数为偶数，偶数乘偶数为偶数</li>
<li>除了 $2$，质数均为奇数。因此除了 $2$，质数的任意次幂都是奇数。</li>
</ul>
<p>假设 $\sigma_1(N)=(1+P_1+P_1^2+\cdots+P_1^{a_1})(1+P_2+P_2^2+\cdots+P_2^{a_2})\cdots(1+P_n+P_n^2+\cdots+P_n^{a_n})$ 为奇数，那么：</p>
<p>**情况 1：**若 $2\mid N$，那么 $P_1=2$，所以 $P_1+P_1^2+\cdots+P_1^{a_1}$ 为偶数，$1+P_1+P_1^2+\cdots+P_1^{a_1}$ 为奇数。</p>
<p>如果 $\sigma_1(N)$ 为奇数，那么 $(1+P_2+P_2^2+\cdots+P_2^{a_2}),\cdots,(1+P_n+P_n^2+\cdots+P_n^{a_n})$ 均为奇数</p>
<p>即 $(P_2+P_2^2+\cdots+P_2^{a_2}),\cdots,(P_n+P_n^2+\cdots+P_n^{a_n})$ 均为偶数</p>
<p>因为 $P_2,\cdots,P_n$ 均为质数，由结论可知，一定是偶数个奇数相加，即 $a_2,\cdots,a_n$ 均为偶数</p>
<p>**情况 1.1：**若 $a_1$ 为偶数，$N=P_1^{a_1}\cdot P_2^{a_2}\cdot P_3^{a_3}\cdots P_n^{a_n}=(P_1^{a_1/2}\cdot P_2^{a_2/2}\cdot P_3^{a_3/2}\cdots P_n^{a_n/2})^2$ 为完全平方数 $x^2$</p>
<p>**情况 1.2：**若 $a_1$ 为奇数， $N=P_1^{a_1}\cdot P_2^{a_2}\cdot P_3^{a_3}\cdots P_n^{a_n}=P_1\times(P_1^{(a_1-1)/2}\cdot P_2^{a_2/2}\cdot P_3^{a_3/2}\cdots P_n^{a_n/2})^2$ 为完全平方数的两倍 $2\cdot x^2$</p>
<p>**情况 2：**若 $2\nmid N$，同上得 $(P_1+P_1^2+\cdots+P_1^{a_2}),\cdots,(P_n+P_n^2+\cdots+P_n^{a_n})$ 均为偶数</p>
<p>所以 $N=P_1^{a_1}\cdot P_2^{a_2}\cdot P_3^{a_3}\cdots P_n^{a_n}=(P_1^{a_1/2}\cdot P_2^{a_2/2}\cdot P_3^{a_3/2}\cdots P_n^{a_n/2})^2$ 为完全平方数 $x^2$</p>
<p>**综上所述：**若 $N=x^2\ 或\ 2\cdot x^2$，$\sigma_1(N)$ 为奇数，反之为偶数。</p>
<p>代码实现非常简单，略去。</p>
<h2 id="4-3-欧拉函数-Euler’s-totient-function">4.3 欧拉函数 Euler’s totient function</h2>
<p>对正整数 $n$，欧拉函数是小于 $n$ 的正整数中与 $n$ 互质的数的数目，记作 $\varphi(n)$。</p>
<p>若 $n$ 有标准分解 $p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}$，其中 $p_i$ 为互异的质因子，$k_i\geq1$ 为质因子的次数。则欧拉函数的值为：<br>
$$<br>
\varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_r})<br>
$$<br>
需要注意：$\varphi(1)=1$</p>
<h3 id="4-3-1-朴素法">4.3.1 朴素法</h3>
<p>时间复杂度：$O(\sqrt{n})$</p>
<p>该方法仅求得 $n$ 的欧拉函数值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    cin &gt;&gt; a;<br>    <span class="hljs-type">int</span> ans = a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(a % i))<br>        &#123;<br>            ans = ans / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (!(a % i))<br>                a /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">1</span>)<br>        ans = ans / a * (a - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-2-线性筛法">4.3.2 线性筛法</h3>
<p>时间复杂度：$O(n)$</p>
<p>该方法求得 $1\sim n$ 的所有欧拉函数值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> prime[MAXN], phi[MAXN], idx;<br><span class="hljs-type">bool</span> is_prime[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(is_prime, <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(is_prime));<br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i])<br>        &#123;<br>            prime[idx++] = i;<br>            phi[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; idx &amp;&amp; i * prime[j] &lt;= n; j++)<br>        &#123;<br>            is_prime[i * prime[j]] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!(i % prime[j]))<br>            &#123;<br>                phi[i * prime[j]] = phi[i] * prime[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            phi[i * prime[j]] = phi[i] * (prime[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-4-扩展欧几里得算法-Extended-Euclidean-algorithm">4.4 扩展欧几里得算法 Extended Euclidean algorithm</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求模数非质数的乘法逆元</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exgcd</span>(a, p, x, y) != <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 无解</span><br>    <span class="hljs-keyword">return</span> (x % p + p) % p;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-5-扩展中国剩余定理-exCRT">4.5 扩展中国剩余定理 exCRT</h2>
<p>有以下一元线性同余方程组：<br>
$$<br>
(S) : \quad \left{ \begin{matrix} x \equiv a_1 \pmod {m_1} \ x \equiv a_2 \pmod {m_2} \ \vdots \qquad\qquad\qquad \ x \equiv a_n \pmod {m_n} \end{matrix} \right.<br>
$$</p>
<p><strong>不保证</strong>整数 $m_1,m_2,\dots,m_n$ 其中任两数互质，问：方程组是否有解？若有解，试求 $x$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    ll d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-comment">// 如果中途输出-1, -1则需要立即停止</span><br><span class="hljs-comment">// first-a second-mod</span><br><span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">excrt</span><span class="hljs-params">(pair&lt;ll, ll&gt; a, pair&lt;ll, ll&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ya, yb;<br>    ll d = <span class="hljs-built_in">exgcd</span>(a.second, b.second, ya, yb);<br>    <span class="hljs-keyword">if</span> ((b.first - a.first) % d)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    ya *= (b.first - a.first) / d;<br>    ll tmp = b.second / d;<br>    ya = (ya % tmp + tmp) % tmp;<br>    a.first += a.second * ya;<br>    a.second = a.second / d * b.second;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-6-高斯消元法-Gaussian-Elimination">4.6 高斯消元法 Gaussian Elimination</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">110</span>;     <span class="hljs-comment">// 最大方程数</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS = <span class="hljs-number">1e-6</span>;  <span class="hljs-comment">// 浮点误差</span><br><span class="hljs-type">int</span> n;                    <span class="hljs-comment">// 方程个数</span><br><span class="hljs-type">double</span> mat[MAXN][MAXN];   <span class="hljs-comment">// 增广矩阵</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> row, col;<br>    <span class="hljs-keyword">for</span> (row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>; col &lt; n; col++)<br>    &#123;<br>        <span class="hljs-type">int</span> max_row = row;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(mat[i][col]) &gt; <span class="hljs-built_in">fabs</span>(mat[max_row][col]))<br>                max_row = i;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(mat[max_row][col]) &lt; EPS)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = col; i &lt;= n; i++)<br>            <span class="hljs-built_in">swap</span>(mat[max_row][i], mat[row][i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= col; i--)<br>            mat[row][i] /= mat[row][col];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row + <span class="hljs-number">1</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(mat[i][col]) &gt; EPS)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= col; j--)<br>                    mat[i][j] -= mat[i][col] * mat[row][j];<br>        row++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (row &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(mat[i][n]) &gt; EPS)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 无解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 无穷解</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            mat[i][n] -= mat[i][j] * mat[j][n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 有唯一解</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-7-组合数-Combination">4.7 组合数 Combination</h2>
<h3 id="4-7-1-公式法">4.7.1 公式法</h3>
<p>$$<br>
C_n^k={n\choose k}=\frac{P_{k}^{n}}{k!}=\frac{n!}{k!(n-k)!}<br>
$$</p>
<p>时间复杂度：$O(n\log p)$ (预处理阶乘和逆元) ，$O(1)$ (得到组合数)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fast_pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)</span> <span class="hljs-comment">// 快速幂</span></span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)</span></span>; <span class="hljs-comment">// 求逆元</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = invf[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXA; i++)<br>    &#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % MOD;<br>        invf[i] = invf[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">inv</span>(i) % MOD;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// c_a^b = fact[a] * invf[b] % MOD * invf[a - b] % MOD</span><br></code></pre></td></tr></table></figure>
<h3 id="4-7-2-递推法">4.7.2 递推法</h3>
<p>$$<br>
C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}<br>
$$</p>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXA = <span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[MAXA][MAXA];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXA; i++)<br>        ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXA; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; MAXA; j++)<br>            ans[i][j] = (ans[i - <span class="hljs-number">1</span>][j] + ans[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-7-3-卢卡斯定理">4.7.3 卢卡斯定理</h3>
<p>$$<br>
C_{m}^{n}\equiv C_{m/p}^{n/p}\cdot C_{m\bmod p}^{n\bmod p}\pmod p<br>
$$</p>
<p>时间复杂度：$O(p\log p\cdot\log_p{n})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXA = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> fact[MAXA];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> mod)</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mod; i++)<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fast_pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    b %= p;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>)<br>            ans = a * ans % p;<br>        a = a * a % p;<br>        b /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fast_pow</span>(x, p - <span class="hljs-number">2</span>, p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">comb</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b &gt; a)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)<br>        <span class="hljs-keyword">return</span> fact[a] * <span class="hljs-built_in">inv</span>(fact[b], p) % p * <span class="hljs-built_in">inv</span>(fact[a - b], p) % p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">comb</span>(a % p, b % p, p) * <span class="hljs-built_in">comb</span>(a / p, b / p, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>        <span class="hljs-built_in">init</span>(p);<br>        cout &lt;&lt; <span class="hljs-built_in">comb</span>(a, b, p) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-7-4-高精度算法">4.7.4 高精度算法</h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">a, b = <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27; &#x27;</span>)<br>a = <span class="hljs-built_in">int</span>(a)<br>b = <span class="hljs-built_in">int</span>(b)<br>res = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a - b + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span>):<br>    res *= i<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>):<br>    res //= i<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>
<h2 id="4-8-容斥原理-Include-Exclude-Principle">4.8 容斥原理 Include-Exclude Principle</h2>
<p>$$<br>
{\displaystyle {\begin{aligned}\left|\bigcup <em>{i=1}^{n}A</em>{i}\right|={}&amp;\sum <em>{i=1}^{n}|A</em>{i}|-\sum <em>{1\leq i&lt;j\leq n}|A</em>{i}\cap A_{j}|+\sum <em>{1\leq i&lt;j&lt;k\leq n}|A</em>{i}\cap A_{j}\cap A_{k}|-\cdots +(-1)^{n-1}\left|A_{1}\cap \cdots \cap A_{n}\right|.\end{aligned}}}<br>
$$</p>
<h2 id="4-9-哥德巴赫猜想-Goldbach-Conjecture">4.9 哥德巴赫猜想 Goldbach Conjecture</h2>
<ul>
<li>任一大于 $2$ 的偶数，都可表示成两个素数之和。</li>
<li>大于 $5$ 的奇数都可以表示成三个素数之和。</li>
<li>任意一个大于 $4$ 的偶数都可以拆成两个奇素数之和。</li>
</ul>
<h2 id="4-10-范德蒙德卷积-Vandermonde-Convolution">4.10 范德蒙德卷积 Vandermonde Convolution</h2>
<p>范德蒙德卷积公式：<br>
$$<br>
\sum_{i=0}^{k}{n\choose i}{m\choose k-i}={n+m\choose k}<br>
$$<br>
推论 $1$：<br>
$$<br>
\sum_{i=-r}^{s}{n\choose r+i}{m\choose s-i}={n+m\choose r+s}<br>
$$<br>
推论 $2$：<br>
$$<br>
\sum_{i=1}^{n}{n\choose i}{n\choose i-1}={2n\choose n-1}<br>
$$<br>
推论 $3$：<br>
$$<br>
\sum_{i=0}^{n}{n\choose i}^2={2n\choose n}<br>
$$<br>
推论 $4$：<br>
$$<br>
\sum_{i=0}^{m}{n\choose i}{m\choose i}={n+m\choose m}<br>
$$</p>
<h2 id="4-11-二项式定理以及推论">4.11 二项式定理以及推论</h2>
<p>二项式定理：<br>
$$<br>
(a+b)^n=\sum_{i=0}^{n}{n\choose i}a^{n-i}b^{i}<br>
$$<br>
多项式推广：<br>
$$<br>
(x_1+x_2+\cdots+x_t)^n=\sum_{满足n_1+\cdots+n_t=n的非负整数解}{n\choose n_1,n_2,\cdots,n_t}x_1^{n_1}x_2^{n_2}\cdots x_t^{n_t}<br>
$$<br>
组合数性质、二项式推论：<br>
$$<br>
{n\choose m}={n\choose n-m}<br>
$$</p>
<p>$$<br>
{n\choose k}=\frac{n}{k}{n-1\choose k-1}<br>
$$</p>
<p>$$<br>
{n\choose m}={n-1\choose m}+{n-1\choose m-1}<br>
$$</p>
<p>$$<br>
{n\choose 0}+{n\choose 1}+\cdots+{n\choose n}=\sum_{i=1}^n{n\choose i}=2^n<br>
$$</p>
<p>$$<br>
\sum_{i=0}^n(-1)^i{n\choose i}=[n=0]<br>
$$</p>
<p>$$<br>
\sum_{i=0}^{m}{n\choose i}{m\choose m-i}={m+n\choose m};(n\geq m)<br>
$$</p>
<p>$$<br>
\sum_{i=0}^n i^2{n\choose i}=n(n+1)2^{n-2}<br>
$$</p>
<p>$$<br>
\sum_{l=0}^{n}{l\choose k}={n+1\choose k+1}<br>
$$</p>
<p>$$<br>
{n\choose r}{r\choose k}={n\choose k}{n-k\choose r-k}<br>
$$</p>
<p>$$<br>
\sum_{i=0}^n{n-i\choose i}=\text{Fibonacci}_{n+1}<br>
$$</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" class="category-chain-item">技术分享</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/" class="print-no-link">#c++</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="print-no-link">#数据结构与算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法模板</div>
      <div>https://emopps.github.io/2025/09/12/c++板子/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>emopps</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/" title="操作系统八股文">
                        <span class="hidden-mobile">操作系统八股文</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
