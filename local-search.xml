<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统八股文</title>
    <link href="/2025/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2025/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1>操作系统八股文</h1><h2 id="死锁的发生条件，如何解决">死锁的发生条件，如何解决</h2><p>死锁是指一组进程/线程互相等待对方持有的资源,导致它们都无法继续执行的情况。死锁的产生有四个条件，互斥，不可剥夺，请求和保持以及循环等待。要解决死锁问题只要破解其中一个条件即可。<br>进程调度算法可以通过以下方式来<strong>预防和解决死锁</strong>:</p><ul><li>银行家算法: 预先分配资源,确保不会进入死锁状态。</li><li>资源分配图算法: 检测资源分配图中是否存在环路,从而判断是否会发生死锁。</li><li>死锁检测与解除: 定期检测系统中是否存在死锁,如果存在则通过抢占资源或者终止进程来解除死锁。</li></ul><h2 id="进程和线程的区别？">进程和线程的区别？</h2><p>进程是<strong>资源分配的基本单位</strong>，线程是<strong>CPU调度的基本单位</strong>。<br>从并发性角度看，切换进程是要涉及到虚拟内存空间的切换的，线程切换不涉及，多线程共享同一个虚拟内存空间，进程切换还会涉及上下文（即寄存器组）的切换。进程在创建时会申请内存，每个进程内都有一个页表存在于内存中。切换进程导致页表中的TLB快表失效，寄存器内的内容都需要重新写入，被终止运行的进程的中间数据会存在进程的私有堆栈中，线程的切换就不会使TLB失效，速度就会快很多。多个线程之间共享的部分有全局变量和静态变量，堆，部分全局数据结构和共享库以及动态链接库。</p><h2 id="进程的调度策略">进程的调度策略</h2><ul><li>先到先服务：非抢占式调度，实现简单但可能导致&quot;护航效应&quot;</li><li>最短作业优先：最小化平均等待时间，长进程可能饥饿</li><li>轮转调度：性能开销大或退化为先来先服务</li><li>多级反馈队列：I/O密集型进程：升至高优先级队列（快速响应）。CPU密集型进程：降至低优先级队列（避免抢占开销）。进程老化：低优先级进程随等待时间自动升级</li></ul><h2 id="虚拟内存是如何工作的？">虚拟内存是如何工作的？</h2><p>虚拟内存是现代操作系统的核心内存管理技术，通过硬件（如MMU）与软件（操作系统）的协同，为进程提供连续的虚拟地址空间，并动态映射到物理内存或磁盘空间。</p><ul><li>虚拟地址空间机制：每个进程拥有独立的虚拟地址空间（如32位系统为4GB），进程仅使用虚拟地址（VA）访问内存。虚拟内存包含RAM和磁盘交换空间，拓展可用内存，如手机使用虚拟内存机制提高可用内存。</li><li>分页机制：虚拟地址空间被划分为固定大小的页，操作系统为每个进程维护的映射表，存储虚拟页号（VPN）到物理页框号（PFN）的映射关系。</li></ul><p>虚拟内存的<strong>优点</strong>：防止进程越界访问，提升安全性。允许程序使用超过物理内存的空间。</p><p>常用的<strong>虚拟内存的性能优化</strong>技术:</p><ul><li>加速地址转换：TLB（快表）​：TLB是MMU内部的硬件缓存，存储近期使用的PTE，避免频繁访问主存页表。</li><li>多级页表：仅加载活跃部分的子页表，减少内存占用。</li></ul><h2 id="介绍一下用户态和内核态？">介绍一下用户态和内核态？</h2><p>用户态（User Mode）和内核态（Kernel Mode）是操作系统中的两种核心运行模式，用于隔离应用程序与系统核心功能，保障系统安全性和稳定性。通过系统调用、中断和异常实现动态切换，平衡效率与安全。</p><ul><li><p>用户态：应用程序独占，通过用户级页表映射物理内存，禁止执行特权指令，尝试执行会触发异常并切换到内核态</p></li><li><p>核心态：所有进程共享，通过内核级页表映射操作系统代码和数据，用户程序无法修改，可执行所有指令，可以访问内核资源。</p></li></ul><h2 id="上下文切换时需要保存用户态的哪些内容？">上下文切换时需要保存用户态的哪些内容？</h2><p>操作系统保存的内容如下：( 所有用户态上下文保存在<strong>进程控制块</strong>)上下文切换的本质是保存与恢复进程的执行现场。</p><ul><li>寄存器状态：如程序计数器，堆栈指针，通用寄存器和状态寄存器的状态，需要记录</li><li>栈信息：保存了<strong>函数调用帧</strong>，切换时需要完整保存。</li><li>内存管理信息：上下文切换时需要记录内存管理信息，如页表基址和段寄存器。</li><li>其他用户态状态：如浮点寄存器或者线程的局部存储指针。</li></ul><p>触发场景：主动切换如系统调用，被动切换如时间片耗尽。如果是内核态切换还会记录中断状态、内核栈等系统级信息。</p><h2 id="操作系统如何管理堆上的碎片？">操作系统如何管理堆上的碎片？</h2><p>内存碎片分为内部和外部碎片。管理方法：</p><ul><li><strong>分页</strong>机制：(消除外部碎片)将物理内存划分为固定大小的页框​（如4KB），虚拟地址空间划分为相同大小的页。通过页表映射虚拟页到物理页框，​解除物理地址连续性要求，彻底消除外部碎片</li><li>内存压缩：移动进程内存位置，合并空闲区域形成连续大块。</li><li>伙伴系统：内存按2^n大小分级。分配时递归二分大块，释放时检查相邻块（“伙伴”）是否空闲，若空闲则合并为更大块。</li><li>Slab分配器：预分配固定大小内存池（如Linux kmalloc的Slab缓存），直接从池中分配/释放对象。</li><li>用户级分配器优化：​合并空闲块，分离空闲列表，延迟释放内存。</li></ul><h2 id="CPU的多级缓存是什么样的？">CPU的多级缓存是什么样的？</h2><p>CPU的多级缓存是一种分层存储结构，旨在解决CPU与主存（DRAM）之间的速度鸿沟。其核心设计基于<strong>局部性原理</strong>​（时间局部性与空间局部性），通过多级高速缓存（SRAM）减少访问延迟，提升系统性能。通过空间换时间，将平均内存访问延迟降低10-100倍<br>CPU访问数据的顺序为：<br>​寄存器 → L1 → L2 → L3 → 主存​<br>​缓存命中​：数据在当前缓存层找到，直接返回（如L1命中仅需1-3周期）<br>​缓存未命中​：逐级向下查找，若L3未命中则访问主存，延迟骤增（主存延迟达100-300周期）<br>​数据加载​：未命中时，缓存以缓存行​（通常64字节）为单位从下级存储加载数据，利用空间局部性。</p><h2 id="缓存一致性？">缓存一致性？</h2><p>缓存一致性（Cache Coherence）是计算机系统中确保多个缓存副本数据一致的关键机制，尤其在多核处理器、分布式系统或多级缓存架构中至关重要。其核心目标是<strong>解决因缓存复制导致的数据不一致问题</strong>，避免程序逻辑错误。<br>多核CPU的缓存一致性协议：<strong>MESI协议​</strong><br>每个缓存行（Cache Line）通过4种状态管理数据一致性<br>​M（Modified）​​：数据被修改，仅当前缓存有效，主存数据已过期。<br>​E（Exclusive）​​：数据未被修改，仅当前缓存持有，主存数据最新。<br>​S（Shared）​​：数据未被修改，多个缓存共享，主存数据最新。<br>​I（Invalid）​​：缓存行数据无效，需重新加载。<br>运行机制：<br>当核心A修改数据时，通过总线广播消息，使其他核心中该数据的缓存行状态变为Invalid（写无效策略）。其他核心再次访问时需重新从主存或核心A的缓存加载最新数据</p><h2 id="操作系统是如何检测死锁的？">操作系统是如何检测死锁的？</h2><p>操作系统检测死锁的核心机制是通过实时监控进程的资源请求与分配关系，判断是否满足死锁的四个必要条件（<strong>互斥、持有等待、不可剥夺、循环等待</strong>）。<br>主流有2种检测方法：</p><ul><li>资源分配图法：将进程和资源建模为有向图，通过检测环路判断死锁。构建当前系统快照，​简化图结构​，判断死锁。</li><li>银行家算法：通过模拟资源分配，检查系统是否处于安全状态。</li></ul><h2 id="什么时候使用进程？什么时候使用线程？">什么时候使用进程？什么时候使用线程？</h2><p><strong>进程</strong>的适用场景：</p><ul><li>需要强隔离性与稳定性：如核心服务（数据库、OS模块）、安全敏感模块（支付系统）。</li><li>跨多核CPU的并行计算：科学计算、视频渲染、机器学习训练</li><li>资源独占需求：独立内存管理（如JVM进程）、专用硬件访问（GPU）</li></ul><p><strong>线程</strong>的适用场景：</p><ul><li>​高并发IO密集型任务：Web服务器（Nginx/Tomcat）、爬虫、实时聊天系统。</li><li>共享数据频繁的任务：GUI应用（后台线程更新UI）、多线程下载（分块共享进度）</li><li>轻量级任务调度：定时任务、后台日志写入、低延迟实时控制。</li></ul><h2 id="进程和线程有没有独立空间？具体的说一下？">进程和线程有没有独立空间？具体的说一下？</h2><p>进程是操作系统资源分配的基本单位，拥有完全独立的虚拟地址空间，其内存结构包含以下区域:代码段、数据段、堆、栈、内存映射区</p><p>线程是CPU调度的基本单位，隶属于进程，其内存空间分为两部分：</p><ul><li>共享区域：代码段、数据段、堆、内存映射区</li><li><strong>私有区域</strong>：栈(存储局部变量和函数调用链)、线程局部存储、寄存器上下文</li></ul><h2 id="CPU调度是以进程还是线程的形式实现的？">CPU调度是以进程还是线程的形式实现的？</h2><p>CPU调度的基本单位是<strong>线程</strong>，优点是：</p><ul><li>​轻量级上下文切换</li><li>细粒度并发控制</li><li>资源分配与调度的分离</li></ul><p>Linux中使用轻量级进程LWP，直接调度ready状态的线程分配时间片。<br>线程调度策略主要有：</p><ul><li>时间片轮转</li><li>优先级调度</li><li>负载均衡</li></ul><h2 id="操作系统如何管理内存？">操作系统如何管理内存？</h2><p>操作系统管理内存的方法主要是物理内存管理和虚拟内存管理两种。虚拟内存上面已经讲过了。<br><strong>物理内存管理</strong>策略：</p><ul><li>连续分配策略：连续分配策略分为固定分区​、动态分区和伙伴系统​</li><li>非连续分配策略：分页管理、分段管理和段页式结合。</li></ul><h2 id="虚拟内存有哪些页面调度算法？">虚拟内存有哪些页面调度算法？</h2><p>虚拟内存中的页面调度算法是操作系统在物理内存不足时，决定哪些页面应被换出到磁盘的核心策略。(<strong>程序局部性原理​</strong>)</p><ul><li>先进先出：维护页面进入时间的队列，置换队首页面。适用于简单嵌入式系统或对性能要求不高的场景。</li><li>最近最少使用(LRU):时间戳​记录每个页面的最后访问时间，淘汰时间最早的页面。</li><li>最近最不常用(LFU):为每个页面设置计数器，访问时计数器递增；定期（如每秒）清零计数器避免历史权重过大。适用于访问模式稳定的应用（如数据库缓存）</li><li>最佳置换(OPT):需预知未来页面访问序列（实际不可实现），仅用于理论对比。</li><li>随机置换：依赖硬件随机数生成器<br><strong>优化</strong>版本：</li><li>Clock算法：LRU的近似实现，通过访问位（Reference Bit）​​ 标记页面是否被访问</li><li>工作集模型：基于时间窗口（如最近τ次访问），统计活跃页面</li><li>页面缓冲算法：将被淘汰页面暂存缓冲池，若短期内再次访问可直接恢复，减少磁盘I/O</li></ul><h2 id="什么是僵尸进程？什么是孤儿进程？这两者会带来什么风险？">什么是僵尸进程？什么是孤儿进程？这两者会带来什么风险？</h2><p>僵尸进程和孤儿进程是操作系统中两种特殊的进程状态，尤其在类UNIX系统（如Linux）中常见。</p><ul><li>僵尸进程：子进程已执行结束，但是未被父进程回收，进程表中仍保留其记录。不占用CPU或内存，但占用进程ID，无法被 kill -9 终止，只能由父进程回收。会导致进程表耗尽、资源泄漏隐患和安全风险。</li><li>孤儿进程：父进程先于子进程终止，子进程失去父进程管理，由初始进程负责其资源回收。仍在运行，但父进程ID（PPID）变为1。会导致资源占用​、管理复杂性​和安全风险。</li></ul><h2 id="页表是进程还是线程级别？">页表是进程还是线程级别？</h2><p>页表是进程管理的。<br>进程拥有独立的页表：每个进程创建时，操作系统会为其分配独立的页表结构，用于管理虚拟地址到物理地址的映射关系。这种独立性确保了进程间内存空间的隔离性。同一进程内的所有线程<strong>共享</strong>该进程的页表。<br><strong>特例</strong>：<br>内核线程（如kthreadd）​不关联用户空间，因此无需用户态页表，仅使用内核页表（所有进程共享）。但此类线程属于内核调度实体，与用户级线程/进程的设计目标不同。</p><h2 id="OS检测core-dump发生的机制是什么？">OS检测core dump发生的机制是什么？</h2><p>操作系统（OS）检测并生成 Core Dump 的机制是一个多步骤的协作过程，涉及<strong>信号触发、内核处理、资源检查和内存捕获</strong>等关键环节。<br>信号触发捕获异常事件，操作系统内核接收到信号后，递送信号，检查资源，调用 do_coredump()，然后内存捕获，生成core dump，最后终止进程。</p><h2 id="缺页中断什么时候触发">缺页中断什么时候触发?</h2><ul><li>当程序试图访问的页面（Page）不在物理内存（RAM）中时，操作系统无法立即满足这个请求，这将触发⼀个缺页中断。这种情况通常发⽣在虚拟内存系统中，其中只有部分页面被加载到物理内存中。</li><li>当程序试图执行的操作违反了内存保护规则时，也会触发缺页中断。例如，程序试图写⼊⼀个只读页⾯，或者试图访问⼀个没有权限访问的页⾯。</li></ul><h2 id="有名管道和匿名管道的区别">有名管道和匿名管道的区别?</h2><ul><li>匿名管道：只能用于具有父子关系的进程之间通讯。在创建管道时，调用pipe() 函数即可，管道不存在于文件系统中，只存在于内存中，因此无法被其他进程访问。</li><li>有名管道：可以用于任意两个进程之间通讯，不管它们是否具有父子关系。在创建管道时，需要调用 mkfifo() 函数，管道会创建一个文件系统中的特殊文件，可以像普通文件一样被多个进程访问。</li></ul><h2 id="共享内存在Linux系统中是如何实现的？">共享内存在Linux系统中是如何实现的？</h2><p>共享内存在Linux系统中是一种高效的进程间通信（IPC）机制，通过让多个进程直接访问同一块物理内存区域实现数据共享，避免了数据复制的开销。其实现主要依赖两种机制：​System V共享内存和POSIX共享内存。共享内存的核心原理就是在物理内存中开辟一块区域，多个进程通过页表映射将其映射到各自的虚拟地址空间</p><ul><li><strong>​System V共享内存</strong>：先创建共享内存，然后映射到进程地址空间，通过指针进行数据读写，如果不用了可以解除映射并删除共享内存。</li><li><strong>POSIX共享内存</strong>：POSIX共享内存基于内存映射文件，更符合文件操作习惯。先创建/打开共享内存，调整大小之后映射到进程空间，不使用该文件时解除映射和删除。</li></ul><h2 id="共享内存和管道的区别">共享内存和管道的区别?</h2><ul><li>共享内存是一种高效的进程通讯方式，允许多个进程直接读写共享的内存区域，因此可以实现数据的快速交换。(共享内存通常是<strong>最快的进程间通信方式</strong>)但是需要特别注意同步和互斥的问题，以防止数据访问冲突。</li><li>管道是一种单向的通讯方式，通常用于父子进程之间的通讯，只支持单向的数据流动。管道数据的传输是通过内核进行缓冲的，因此可能会存在一定的性能开销。</li></ul><h2 id="共享内存的优点？">共享内存的优点？</h2><ul><li><strong>零拷贝</strong>：共享内存避免了数据的复制过程，数据直接存放在内存中，进程可以直接读写内存中的数据，因此具有零拷贝的特性。</li><li><strong>低开销</strong>：由于共享内存是直接存放在内存中的，因此在数据传输过程中几乎没有额外的开销，避免了缓冲操作和系统调用的开销。</li><li><strong>高效性</strong>：共享内存的读写操作速度非常快，适合于高频率和大数据量的通信需求。</li></ul><h2 id="并发和并行的区别？">并发和并行的区别？</h2><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><ul><li>并发是指宏观上在一段时间内能同时运行多个程序，而</li><li>并行则指同一时刻能运行多个指令。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++八股文</title>
    <link href="/2025/07/24/c++%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2025/07/24/c++%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1>C++八股文</h1><h2 id="C-面向对象的三大特性">C++面向对象的三大特性</h2><p><strong>封装</strong>：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。<br><strong>继承</strong>：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。<br><strong>多态</strong>：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。</p><ul><li>静态多态：函数重载</li><li>动态多态：通过虚函数重写</li></ul><h2 id="C-多态的实现">C++多态的实现</h2><p>C++的多态分为静态多态和动态多态。</p><p><strong>静态多态</strong>的实现原理是<strong>函数重载和模板函数</strong>(编译器确定)。</p><ul><li>函数重载指的是在同一个作用域内，可以定义多个函数，它们具有相同的名称但参数列表不同的情况。在调用这些函数时，编译器会根据函数调用时提供的参数类型和数量来确定调用哪个函数。模板函数是指在定义函数时使用了类型参数，让函数适用于多种不同的类型。编译器在编译时根据参数类型生成具体的函数实现。模板函数的实现是通过编译时的模板实例化来实现的。</li></ul><p><strong>动态多态</strong>指的是在<strong>运行时</strong>根据对象的实际类型确定要调用的函数。动态多态实现的方法是<strong>虚函数重写和抽象类</strong>。虚函数是指在基类中定义的函数可以被派生类重写的函数。通过将函数声明为虚函数，我们可以在运行时根据对象的实际类型来确定要调用的函数实现。在C++中，只要将函数声明为虚函数即可实现动态多态。抽象类是指包含至少一个纯虚函数的类，这个类不能被实例化，只能用作基类来派生出其他类。在C++中，可以通过将函数声明为纯虚函数来实现抽象类。其原理就是早绑定和晚绑定。早绑定即编译时确定调用函数的地址，晚绑定即类使用virtual函数时生成虚表存放虚函数的地址，类对象构造时进行初始化。</p><h2 id="C-指针和引用的区别？">C++指针和引用的区别？</h2><p>在 C++中，引用本身并不占用额外的内存空间。当你传递一个变量作为引用参数给函数时，函数内部会使用该引用来直接操作原始变量，而不是创建原始变量的副本。因此，使用引用可以避免不必要的数据复制，提高程序的效率。引用的内部实现通常是通过指针来完成的，因此在函数调用时，引用本身并不会在栈上分配额外的内存空间，只是会使用一个指针来指向原始变量的内存地址。总结起来，引用不占用函数栈内存，但会占用一个指针的大小。<br>指针与引用的区别：</p><ul><li>指针本身是一个对象，允许进行赋值和拷贝等操作。</li><li>指针的生命周期内可以指向几个不同的对象，引用不可以。</li><li>指针不需要在定义时赋初值。<br>需要注意的是，引用在底层实现上通常被编译器实现为指针，但是在使用时更类似于被引用的变量本身。引用在编译时会被转换为指针。引用在被使用的使用会占用4个字节大小的内存空间，也就是一个指针的大小</li></ul><h2 id="C-的构造函数能否定义为虚函数？">C++的构造函数能否定义为虚函数？</h2><p>不能。</p><ul><li><p>虚函数通过虚表实现多态，每个类内存有一个虚表，表内存放虚指针。这个虚指针是构造对象时被初始化的。</p></li><li><p><strong>虚函数的工作机制</strong>：虚函数通过虚函数表（vtable）来实现多态。每个包含虚函数的类都有一个虚函数表，其中存放了指向该类虚函数的指针。每个对象在创建时，会有一个指向其虚函数表的指针（vptr）。这个vptr是在对象构造期间被初始化的。从构造函数的<strong>调用时序</strong>看，在构造一个派生类对象时，首先调用基类的构造函数，然后依次调用派生类的构造函数。在基类构造函数执行期间，对象的类型是基类类型，而不是派生类类型。C++语言标准明确规定，构造函数不能是虚函数。如果你尝试在构造函数声明前加上virtual关键字，编译器会报错。</p></li></ul><h2 id="智能指针有没有了解？shared-ptr和unique-ptr讲一下">智能指针有没有了解？shared_ptr和unique_ptr讲一下</h2><p>智能指针的实现是利用了RAII的技术对普通指针进行封装，使得智能指针本质上是一个对象，却表现出一个指针的行为。智能指针的<strong>作用</strong>是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存，解决多次释放同一指针造成崩溃的问题。智能指针还可以把值语义转换成引用语义。</p><p>智能指针的内存问题：智能指针位于栈区域，它管理的对象是位于堆区域。堆区域是程序运行时内存动态分配的地方，智能指针指向堆上的对象，当不再需要这个对象时会自动释放内存。</p><ul><li>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁，因为shared_ptr的指向对象部分并不是线程安全的。</li><li>unique_ptr独占其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。与原始指针相比，unique_ptr由于其RAII的特性，使得在出现异常的情况下，动态资源仍然能得到释放。</li><li>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。C++11中被废弃。</li></ul><h2 id="对锁有没有了解，介绍一下？">对锁有没有了解，介绍一下？</h2><ul><li>mutex:最基本的互斥锁，不可重入</li><li>recursive_mutex：可重入互斥锁，允许同一线程多次加锁</li><li>timed_mutex：带超时功能的互斥锁，尝试获取锁一段时间，超时则返回。</li><li>recursive_timed_mutex：可重入且支持超时</li><li>shared_mutex：读写锁，支持两种访问模式，适用于读多写少的场景。</li><li>shared_timed_mutex：shared_mutex基础上增加了超时功能</li></ul><h2 id="move和forward的区别？">move和forward的区别？</h2><ul><li>move:将对象无条件转换为右值引用，启用移动语义.无论接受左值还是右值，都返回右值引用。实质是静态类型转换：static_cast&lt;T&amp;&amp;&gt;(t)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2 = std::<span class="hljs-built_in">move</span>(s1);  <span class="hljs-comment">// 移动构造，s1 变为空</span><br></code></pre></td></tr></table></figure><ul><li>forward:在模板中完美转发参数，保持原始值类别（左值/右值）。仅在模板中使用（通常是通用引用 T&amp;&amp;）。根据模板参数T的类型决定转发为左值还是右值.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Arg&gt;<br><span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(Arg&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(std::forward&lt;Arg&gt;(arg));  <span class="hljs-comment">// 保持 arg 的原始值类别</span><br>&#125;<br><br>std::string s = <span class="hljs-string">&quot;Test&quot;</span>;<br><span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">create</span>&lt;std::string&gt;(s);       <span class="hljs-comment">// 传递左值 → 调用拷贝构造</span><br><span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">create</span>&lt;std::string&gt;(<span class="hljs-string">&quot;Temp&quot;</span>);  <span class="hljs-comment">// 传递右值 → 调用移动构造</span><br></code></pre></td></tr></table></figure><h2 id="C-的栈容器的内部是什么样的，内存是否连续？">C++的栈容器的内部是什么样的，内存是否连续？</h2><p>C++的栈stack不是独立容器，是基于其他的序列容器的。默认是使用deque双端队列实现。</p><ul><li>deque内存连续，由多个固定大小内存块组成</li><li>vector：完全连续，是开辟了一大块大的内存块用于使用</li><li>list：非连续，双休链表节点分散存储</li></ul><h2 id="shared-ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？">shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？</h2><p>引用计数的<strong>核⼼原理</strong>：</p><ul><li>在shared_ptr的内部维护了⼀个计数器，来跟踪有多少个shared_ptr对象指向了某⼀个资源。当计数器的值减少到0的时候，shared_ptr就会调⽤delete(或者⽤户⾃定义的⽅法)来释放资源。</li></ul><p>引用计数器何时<strong>增加</strong>：</p><ul><li>新建⼀个shared_ptr并指向了⼀个资源时。</li><li>复制构造函数创建⼀个新的shared_ptr时。</li><li>⽤复制运算符将⼀个shared_ptr给另⼀个shared_ptr对象赋值时。</li></ul><p>引⽤计数器何时<strong>减少</strong>：</p><ul><li>当⼀个shared_ptr对象被销毁时，⽐如局部变量离开作⽤域，或者类成员变量析构时。2.</li><li>当⼀个shared_ptr对象不再指向⼀个资源时，例如通过reset⽅法或者赋值运算符指向另⼀个资源时。</li></ul><h2 id="讲一下循环引用如何发生的，以及如何解决？">讲一下循环引用如何发生的，以及如何解决？</h2><p>在两个或多个对象相互引用，或者⼀些复杂的数据结构，如图，双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法被释放掉。这个时候就需要使用weak_ptr来打破循环引⽤。因为使⽤weak_ptr指向某⼀个资源时，它不会增加这个资源的引⽤计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeB</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 使用 shared_ptr 会导致循环引用</span><br>    std::shared_ptr&lt;NodeB&gt; b_ptr;<br>    <span class="hljs-comment">// 解决方案：使用 weak_ptr 替代</span><br>    <span class="hljs-comment">// std::weak_ptr&lt;NodeB&gt; b_ptr;</span><br>    <br>    ~<span class="hljs-built_in">NodeA</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeA 销毁\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;NodeA&gt; a_ptr;<br>    ~<span class="hljs-built_in">NodeB</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeB 销毁\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建两个节点</span><br>    <span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">make_shared</span>&lt;NodeA&gt;();<br>    <span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">make_shared</span>&lt;NodeB&gt;();<br>    <br>    <span class="hljs-comment">// 建立相互引用</span><br>    a-&gt;b_ptr = b;  <span class="hljs-comment">// shared_ptr 版本会导致循环引用</span><br>    b-&gt;a_ptr = a;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a 引用计数: &quot;</span> &lt;&lt; a.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b 引用计数: &quot;</span> &lt;&lt; b.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-comment">// main 结束时，a 和 b 应该被销毁...</span><br>    <span class="hljs-comment">// 但如果使用 shared_ptr，由于循环引用，引用计数不会归零</span><br>    <span class="hljs-comment">// 只有使用 weak_ptr 才能正确销毁</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared-ptr是线程安全的吗？多线程中使用智能指针要注意什么？">shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？</h2><ul><li>多线程代码操作的是同一个shared_ptr的对象是线程不安全的。</li><li>多线程代码操作的不是同一个shared_ptr的对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。</li></ul><h2 id="何时用shared-ptr，何时用weak-ptr">何时用shared_ptr，何时用weak_ptr?</h2><p>在我们需要对引用的资源进行指针之间的共享的时候，我们通常会使用shared_ptr。在使用shared_ptr，weak_ptr会作为一个配合它使用的辅助指针来使用，使用到weak_ptr的场景通常有两种。</p><ul><li>在使用shared_ptr时，我们要解决循环引用的问题，这时我们要用weak_ptr来打破循环引用的问题，避免资源无法被释放。</li><li>当我们需要使用一个共享的内存，但是从业务逻辑上来讲，这个持有不应该对这个资源的生命周期有影响，这时我们也应该使用weak_ptr而不是用shared_ptr。</li></ul><h2 id="介绍⼀下static和const">介绍⼀下static和const</h2><p><strong>Const</strong>:</p><ul><li>基本概念：Const允许我们指定⼀个语义约束, 告诉编译器某个对象不应该被改变。而编译器会强制帮助我们实施这⼀项约束。如果我们认定某个值不能被改变，那么我们就应该使用const，来让编译器帮助我们来保证这个条件不被违反。</li><li>适用场景：const可以修饰很多内容。对于普通对象，可以修饰局部的，全局的，或者区块作⽤域中的普通对象；对于函数，可以修饰函数的返回值，函数的参数；对于指针，可以修饰指针本身（指针常量），也可以修饰指针所指的对象（常量指针）；对于类，可以修饰类的成员变量，也可以修饰类的成员函数。</li></ul><p><strong>Static</strong>:</p><p>C++中的static关键字具有多种用途。可以声明静态成员变量，静态成员函数，静态局部变量，静态全局变量。</p><ul><li>静态成员变量和函数：是类的所有对象共享的成员变量。它们不属于任何特定的对象，而属于类本身。静态成员变量在类的所有对象之间只有⼀个实例。</li><li>静态成员函数：静态成员函数是不依赖于类的任何特定对象的成员数据。它们可以在没有类的对象的情况下调用。</li><li>静态局部变量：静态局部变量是在函数内部声明的静态变量，它与普通局部函数的变量不同，静态局部变量在程序运⾏期间只初始化⼀次，即使函数被多次调用。</li><li>静态全局变量：静态全局变量是全局作用域内声明的静态变量。它们的可用性仅限于定义它们的源文件，意味着它们不能在其它源文件中访问，有助于封装和避免命名冲突。</li></ul><h2 id="new和malloc的区别">new和malloc的区别</h2><ul><li>性质不同：new是⼀个c++中特有的操作符，⽽malloc是c语⾔中的内存分配函数。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。</li><li>内存分配⽅式不同：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的构造函数来初始化对象。</li><li>使⽤语法不同：malloc使⽤时需要指定分配内存的⼤⼩，如malloc(sizeof(int)), 但new不⽤，使⽤更加简洁，如：new int</li><li>返回类型：malloc返回void*类型指针，需要强制转换成其它指定类型，⽽new直接返回响应的数据类型的指针，无需类型转换。</li><li>错误处理：内存分配失败后，malloc返回null, ⽽new会抛出std::bad_malloc异常。</li><li>配对操作：malloc分配内存使用free释放，⽽new分配内存要使用delete释放。</li></ul><h2 id="什么是左值？什么是右值？">什么是左值？什么是右值？</h2><ul><li>左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址。</li><li>右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址。</li></ul><h2 id="C和C-的区别？">C和C++的区别？</h2><p>C++是C加上⼀些⾯向对象的特性。最初C++只是C加上⼀些⾯向对象的特性，但随着语⾔的发展，C++⽀持了更多观念和特性，变得⽐C语⾔更具有弹性和灵活性。现在的C++相⽐C，是⼀个语⾔联邦，它包含了C语⾔，但具有更多特性。</p><ul><li>.C++以C为基础，包含了C语⾔部分。区块，语句，预处理器，内置数据类型，数组，指针等特性都是来⾃于C。</li><li>C++包含了⾯向对象的特性，⽐如封装，继承，多态，virtual函数的特性。</li><li>C++包含了泛型编程的部分。</li><li>C++包含了STL部分。<br>总之，C++是在C语⾔基础上，包含了其它特性⽽发展⽽来的，相⽐C语⾔来说更加灵活和复杂。</li></ul><h2 id="前置-返回的是左值还是右值，后置-呢？字符串字面量呢">前置++返回的是左值还是右值，后置++呢？字符串字面量呢?</h2><ul><li>前置++的实现是直接对传入的对象自增，然后将此对象返回，因此它返回的是⼀个具有名称的稳定的<strong>左值</strong>。</li><li>后置++的实现是创建⼀个临时对象，然后对传入的对象自增，然后返回的是⼀个这个临时的对象，因此它返回的是⼀个<strong>右值</strong>。</li><li>字符串变量也是⼀个左值，因为它会将字符串变量存储到程序的数据段中，程序加载时会为它开辟内存空间，所以我们可以⽤&amp;取地址，所以是左值。</li></ul><h2 id="右值引用是如何提⾼性能的？">右值引用是如何提⾼性能的？</h2><p>右值引⽤主要是通过避免不必要的拷贝操作来提高代码的性能的。</p><h2 id="介绍⼀下RVO？">介绍⼀下RVO？</h2><p>RVO（ReturnValueOptimization）是⼀种编译器优化技术，用于消除不必要的临时对象拷贝，提高代码的性能。RVO主要针对函数返回局部对象的情况，通过优化，可以避免创建临时对象并执行拷贝构造函数。<br>RVO的<strong>基本思想</strong>是：在函数调用栈上直接构造返回值，而不是先构造⼀个局部对象，然后再拷贝到调用者的栈空间。这样可以减少临时对象的创建和销毁，提高代码的运行效率。</p><h2 id="如果一个class的this指针被删除后强行访问会有什么影响？">如果一个class的this指针被删除后强行访问会有什么影响？</h2><p>会出现崩溃或者输出乱码值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">42</span>; <span class="hljs-comment">// 假设有一个成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 销毁对象</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    C *obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">C</span>();<br>    obj-&gt;<span class="hljs-built_in">destroy</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;强行访问 obj-&gt;data: &quot;</span> &lt;&lt; obj-&gt;data &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：<br><img src="image.png" alt="alt text"></p><h2 id="volatile关键字的作用？">volatile关键字的作用？</h2><p>volatile关键字的作用就是防止编译器优化，编译器每次读变量的值都从内存直接读取最新值且写操作时直接写入内存。该关键字不保证线程安全。如果目的是实现原子操作推荐atomic。<br>适用场景：</p><ul><li>硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）</li><li>中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值</li><li>多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全</li><li>防止空循环被优化</li></ul><h2 id="C-函数封装器为什么优于函数指针？">C++函数封装器为什么优于函数指针？</h2><p>函数封装器的<strong>优点</strong>：</p><ul><li>函数封装器兼容函数指针，lambda表达式和仿函数，代码更加简洁、清晰且利于拓展。</li><li>函数封装器类型安全，有严格的类型检查。</li><li>与现代C++特性的深度集成</li><li>面向对象支持</li></ul><h2 id="strcpy的缺点是什么？">strcpy的缺点是什么？</h2><ul><li>strcpy会造成缓冲区溢出并导致不确定的问题。</li><li>strcpy会导致软件漏洞容易被利用。轻则导致程序崩溃，重则导致黑客找到存储器上返回地址的值，替换为恶意程序。</li></ul><h2 id="class和struct的区别？">class和struct的区别？</h2><ul><li>class的默认成员和继承都是private的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。</li><li>struct默认是public的，如果是要给外部提供一些所需的数据可以使用struct。</li></ul><h2 id="C-中switch和if-else的区别在哪里？">C++中switch和if else的区别在哪里？</h2><ul><li>switch只支持整数和枚举类型，如果是仅仅使用整数和枚举类型的逻辑判断，使用switch的性能更佳。编译器会生成一个跳转表给switch语句。考虑代码可读性推荐使用。</li><li>if else可以判断所有的逻辑类型。if else使用遍历的方法。理论上性能会差一点，但是编译器优化后，只要分支不超过100个，switch的性能和if else性能接近。</li></ul><h2 id="C-inline内联的作用？">C++ inline内联的作用？</h2><ul><li>inline内联即直接把该部分的代码复制到调用处，这样就不会有代码调用的call的开销，提高代码的性能，但是会导致代码膨胀，降低编译速度。C++17开始容许多次定义，即2个不同的C++文件中的同名inline内联函数可以实现不同的功能，类似static，对别的C++文件屏蔽该函数。如果在同一个C++文件中设置2个同名内联函数，在链接阶段会出现一个情况，即随机挑选一个函数链接上。(但是我试了一下使用gcc编译这种情况是没办法编译成功的)</li></ul><h2 id="虚函数和纯虚函数的区别？">虚函数和纯虚函数的区别？</h2><ul><li>虚函数是实现C++运行时多态的核心机制，通过virtual关键字声明，当通过基类指针或引用调用虚函数时，会根据对象的实际类型动态绑定到正确的函数实现。虚函数可以有默认实现，派生类可以选择性重写，包含虚函数的类可以实例化。</li><li>纯虚函数通过在虚函数声明后加=0定义，没有默认实现，强制派生类必须重写。包含纯虚函数的类称为抽象类，不能实例化，纯虚函数用于定义接口规范，确保所有派生类都有该功能。<br>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>usingnamespacestd;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 虚函数，有默认实现</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal sound&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 重写虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Woof!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Animal* animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>    animal-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: Woof!</span><br>    <span class="hljs-keyword">delete</span> animal;<br>    return0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>usingnamespacestd;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数，无实现</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> :<span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 必须实现纯虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Drawing a circle&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Shape shape;  // 错误: 不能实例化抽象类</span><br>    Shape* shape = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    shape-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 输出: Drawing a circle</span><br>    <span class="hljs-keyword">delete</span> shape;<br>    return0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="怎么解决菱形继承？">怎么解决菱形继承？</h2><p>C++具备多重继承，导致会出现菱形继承的问题。<br>一个子类继承自多个父类，多个父类本身也可以继承自同一个基类。<br>菱形继承会导致二义性，存储空间浪费的问题。<br>解决方法：</p><ul><li>虚继承：子类只继承一次父类的父类。在中间基类继承父共同基类时加上virtual关键词。其实现原理就是<strong>依靠虚基类表</strong>，编译器为每个虚继承的类生成一个虚基类指针，指向这个虚基类表。虚基类表存储偏移量，用于在运行时定位共享基类成员的位置对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">// 虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MostDerived</span> : <span class="hljs-keyword">public</span> Derived1, <span class="hljs-keyword">public</span> Derived2 &#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="override和final关键字的作用？">override和final关键字的作用？</h2><p>解决不能阻止某个虚函数进一步重写的问题。<br>override:显式标记派生类中的函数是对基类虚函数的覆盖（重写），并强制编译器检查函数签名是否完全匹配。核心机制是签名检查(编译器验证派生类函数的签名是否与基类虚函数一致）和避免假重写。<br>final:禁止类被继承或虚函数被进一步重写，锁定设计意图。修饰类则类不可被继承。修饰虚函数则虚函数在派生类中不可再被重写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 基类虚函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// ✅ 正确覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-comment">// ❌ 编译错误：参数类型不匹配</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// ❌ 编译错误：foo是final的[3,9](@ref)  </span><br>&#125;;  <br></code></pre></td></tr></table></figure><h2 id="C-类型推导的作用和用法？">C++类型推导的作用和用法？</h2><p>C++作为一种强类型语言，类型匹配比较麻烦，所以借助编译器来处理类型推导比较好，提升编码效率。<br><strong>auto</strong>：用于变量的类型的推导，初始化一个值然后去推导变量的类型。如果是使用auto定义多个变量，多个变量必须是同一类型。类型推导会丢失引用和cv语义，可以使用auto&amp;保留，万能引用auto&amp;&amp;,会根据初始值属性判断是左值还是右值引用。常见于lambda表达式。<br><strong>decltype</strong>:推导表达式的类型（保留所有信息)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">20</span>;     <span class="hljs-comment">// b 为 int</span><br><span class="hljs-keyword">decltype</span>(a + <span class="hljs-number">3.14</span>) c;   <span class="hljs-comment">// c 为 double[5](@ref)</span><br></code></pre></td></tr></table></figure><h2 id="function-lambda-bind之间的关系？">function,lambda,bind之间的关系？</h2><p>​Lambda 和 std::bind 是生产者，生成可调用的对象。function是消费者，管理各类对象并提供一致的调用接口。</p><ul><li>function：通用可调用对象的包装器，支持类型擦除，统一存储 Lambda、std::bind 结果等。依赖其他可调用对象作为其内容。</li><li>lambda：生成匿名函数对象（闭包），可捕获外部变量，提供简洁的语法定义临时函数。可独立使用，或作为 std::function/std::bind 的输入。优点是直接内联，系统开销小。</li><li>bind：绑定函数的部分参数，生成新的可调用对象，支持参数重排和占位符机制。常常绑定普通函数、成员函数或 Lambda。</li></ul><h2 id="继承下的构造函数和析构函数执行顺序？">继承下的构造函数和析构函数执行顺序？</h2><p>继承下，构造函数按照依赖链，从上到下进行构造，析构函数是自下往上进行析构。</p><h2 id="虚函数表和虚函数表指针的创建时机？">虚函数表和虚函数表指针的创建时机？</h2><ul><li>虚函数表的创建时机：<strong>编译期生成</strong>。当编译器检测到类中包含 virtual 关键字修饰的虚函数（或继承自基类的虚函数）时，会为该类生成一个虚函数表。虚函数表是一个函数指针数组，按虚函数在类中的声明顺序存储其地址。若派生类重写了基类虚函数，则表中存储派生类函数的地址；未重写则保留基类函数地址。</li><li>虚函数表指针的创建时机：<strong>运行期</strong>对象构造时初始化​。vptr 是对象级别的成员，每个对象独立拥有。它在对象构造阶段被初始化，由编译器在构造函数中插入代码完成。vptr 位于对象内存布局的起始位置，指向所属类的虚函数表。</li></ul><h2 id="虚析构函数的作用？">虚析构函数的作用？</h2><p>虚析构函数的作用：</p><ul><li><strong>确保完整的析构链调用</strong>：当基类指针指向派生类对象时，若基类析构函数未声明为虚函数，delete该指针只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类独有的资源（如动态内存、文件句柄等）无法释放，引发内存泄漏或资源泄漏。虚析构函数通过动态绑定机制，确保delete基类指针时，先调用派生类析构函数，再调用基类析构函数，形成完整的析构链。</li></ul><p>虚析构函数的<strong>适用场景</strong>：</p><ul><li>​多态基类必须使用虚析构</li><li>​抽象接口类</li><li>含动态资源的派生类</li></ul><h2 id="C-11有哪些主要特性？">C++11有哪些主要特性？</h2><p>C++11主要特性：</p><ul><li>1.类型推导</li><li>2.智能指针</li><li>3.右值引用和移动语义</li><li>4.constexpr 编译时计算</li></ul><h2 id="动态库和静态库的区别？">动态库和静态库的区别？</h2><ul><li>静态库​：通过编译器生成目标文件，再用归档工具打包成.a或.lib文件。编译时直接嵌入库代码，符号在链接阶段解析完成。适合嵌入式系统或离线环境。程序启动时<strong>自动加载</strong>。牺牲空间换取独立性和启动速度，适合封闭环境或资源隔离需求。</li><li>​动态库​：编译时添加-fPIC（位置无关码）和-shared选项，生成.so或.dll文件。运行时通过动态加载器解析符号地址。运行时通过API<strong>手动加载</strong>。牺牲部署复杂度换取灵活性和资源共享，适合模块化系统或高频更新场景。</li></ul><h2 id="右值引用和左值引用的区别？">右值引用和左值引用的区别？</h2><p><strong>左值引用</strong>的作用​：</p><ul><li>​减少拷贝​：作为函数参数或返回值时避免数据复制。</li><li>​修改原对象​：通过引用直接操作原始数据。</li><li>​生命周期管理​：const T&amp; 可延长临时对象的生命周期至引用作用域结束。</li></ul><p><strong>右值引用</strong>的作用：</p><ul><li>通过&quot;窃取&quot;临时对象的资源（如堆内存），避免深拷贝。</li><li>完美转发：在模板中保持参数的原始值类别（左值/右值），通过forward转发。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-built_in">target</span>(std::forward&lt;T&gt;(arg)); <span class="hljs-comment">// 保留左值/右值属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-什么时候生成默认拷贝构造函数？">C++什么时候生成默认拷贝构造函数？</h2><p>默认拷贝构造函数（执行浅拷贝）在以下四种情况下会被编译器自动生成：</p><ul><li>类成员包含有拷贝构造函数的类对象</li><li>类继承自有拷贝构造函数的基类</li><li>类包含虚函数</li><li>​类存在虚继承</li></ul><h2 id="C-类型推导为什么会有额外的开销？">C++类型推导为什么会有额外的开销？</h2><p>C++的类型推导之所以会有额外的开销，是因为以下几个原因：</p><ul><li>1.推导规则复杂：auto会忽略初始化表达式的顶层const、引用和数组退化。需编译器多步分析。decltype的值类别敏感，需根据表达式是变量、函数调用或带括号的左值，分别应用不同规则推导。</li><li>2.模板实例化负担：在模板中使用auto或decltype推导返回值时，可能触发多次模板实例化。</li><li>3.​意外的值拷贝:若初始化表达式返回引用，但auto未显式声明引用，会进行值拷贝。</li></ul><h2 id="C-如何搜索链接到so动态库中的符号的？">C++如何搜索链接到so动态库中的符号的？</h2><p>C++链接到动态库的过程：</p><ul><li>​动态库加载与初始化：操作系统通过 mmap 将库文件映射到进程地址空间，动态链接器解析库的依赖关系，递归加载所有依赖库。</li><li>符号查找顺序：动态链接器按固定顺序解析符号，先加载主程序符号表，再进行广度搜索逐层加载动态库，最后加载全局符号表</li><li>使用符号绑定机制：符号绑定机制分为立即绑定和延迟绑定，延迟绑定通过全局偏移表实现符号的解析。</li></ul><h2 id="vector与普通数组的区别？vector扩容如何影响复杂度？">vector与普通数组的区别？vector扩容如何影响复杂度？</h2><p>vector和数组的区别在于：vector是动态大小，能够自动管理堆内存，有边界检查，并提供了一些功能接口。vector扩容时会将老的元素复制到新开辟的内存空间中，频繁扩容会导致性能下滑。</p><h2 id="进程同步的技术有哪些？">进程同步的技术有哪些？</h2><p>进程同步技术主要用于协调多个进程对共享资源的访问，避免竞态条件（Race Condition）和数据不一致问题。</p><ul><li>互斥锁：通过锁定机制确保同一时刻只有一个进程能访问临界区资源。适用于简单共享资源的<strong>独占访问</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">critical_section</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 自动加锁</span><br>    <span class="hljs-comment">// 访问共享资源</span><br>&#125; <span class="hljs-comment">// 自动解锁</span><br></code></pre></td></tr></table></figure><ul><li>​信号量：通过计数器控制<strong>多个进程</strong>对共享资源的访问权限。适用于资源池的管理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><span class="hljs-function">std::counting_semaphore&lt;10&gt; <span class="hljs-title">sem</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 允许3个进程同时访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access_resource</span><span class="hljs-params">()</span> </span>&#123;<br>    sem.<span class="hljs-built_in">acquire</span>(); <span class="hljs-comment">// 获取信号量</span><br>    <span class="hljs-comment">// 使用资源</span><br>    sem.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放信号量</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>条件变量：允许进程等待特定条件成立后再继续执行，需与互斥锁配合使用。通过wait()释放锁并阻塞，通过notify_one()或notify_all()唤醒等待进程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br>std::condition_variable cv;<br><span class="hljs-type">bool</span> data_ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    cv.<span class="hljs-built_in">wait</span>(lock, []&#123; <span class="hljs-keyword">return</span> data_ready; &#125;); <span class="hljs-comment">// 等待条件满足</span><br>    <span class="hljs-comment">// 消费数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>屏障：强制多个进程在指定同步点等待，直到所有进程到达后才继续执行。主要适用于并行计算中分阶段任务等场景。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><span class="hljs-function">std::barrier <span class="hljs-title">sync_point</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 等待5个进程</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 阶段1任务</span><br>    sync_point.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 同步点</span><br>    <span class="hljs-comment">// 阶段2任务</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原子操作：通过硬件指令保证对单个变量的操作不可分割，避免数据竞争。主要适用于高频计数器、无锁数据结构等场景。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    counter.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读写锁：允许多个进程同时读取共享资源，但<strong>写入时需独占访问</strong>。适用于读多写少的共享数据（如配置信息）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br>std::shared_mutex rw_mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mutex)</span></span>; <span class="hljs-comment">// 共享锁（可并发读）</span><br>    <span class="hljs-comment">// 读取数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mutex)</span></span>; <span class="hljs-comment">// 独占锁（互斥写）</span><br>    <span class="hljs-comment">// 写入数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="malloc和new的具体实现？">malloc和new的具体实现？</h2><ul><li>malloc是C标准库函数，其核心是通过操作系统提供的系统调用管理堆内存。使用分配的内存块头部存储元数据，通过链表链接所有空闲块。</li><li>new是C++运算符，其行为包含内存分配和对象构造两阶段，内存分配阶段调用全局operator new函数，默认实现内部调用malloc。对象构造阶段用placement new在已分配内存上调用构造函数。new直接返回响应的数据类型的指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));  <span class="hljs-comment">// 调用malloc分配内存</span><br>MyClass* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">MyClass</span>();    <span class="hljs-comment">// 在memory地址调用构造函数</span><br></code></pre></td></tr></table></figure><h2 id="不相关的进程间能否使用管道实现通信？">不相关的进程间能否使用管道实现通信？</h2><p>不相关的进程之间可以通过<strong>命名管道</strong>实现通信。<br>命名管道：<br>命名管道通过 mkfifo() 或 mknod() 系统调用创建，在文件系统中生成一个特殊的 ​FIFO 文件​（如 ./myfifo）。该文件不存储实际数据，仅作为内核中管道缓冲区的访问入口。<br>任何进程只要知道该文件路径，即可通过 open() 打开管道进行读写，无需亲缘关系。进程以写模式（O_WRONLY）打开管道，调用 write() 向管道写入数据。另一进程以读模式（O_RDONLY）打开管道，调用 read() 从管道读取数据。</p><h2 id="协程是什么？">协程是什么？</h2><p>C++协程（Coroutine）是C++20引入的一种轻量级并发编程机制，它允许函数在执行过程中暂停（挂起）并在稍后恢复，而无需依赖操作系统线程调度，从而简化异步编程、提高资源利用率。<br>协程是一种特殊函数，可在执行中主动挂起，保存当前状态（局部变量、执行位置等），后续通过协程句柄恢复执行。<br>C++20采用<strong>无栈协程模型</strong>，挂起时将上下文（局部变量、寄存器状态）存储在堆上</p><h2 id="C-的重载和C语言的区别在哪里？具体是如何实现？">C++的重载和C语言的区别在哪里？具体是如何实现？</h2><ul><li>C++重载的实现原理是<strong>名字修饰</strong>。汇编阶段使用修饰名生成符号，不同参数列表对应独立符号。C++重载在编译阶段生成唯一符号，链接阶段解析符号，重载解析符号，调用函数时，编译器选择参数最匹配的重载版本。</li><li>C语言：汇编阶段仅用函数名生成符号，同名函数导致符号重复定义。链接阶段C链接器按函数名查找地址，无法区分重载函数。</li></ul><h2 id="C和C-编译出来的文件有什么区别？">C和C++编译出来的文件有什么区别？</h2><p>和C++编译生成的可执行文件（如ELF、PE格式）在格式层面是兼容的（均可由操作系统加载执行），但因其语言特性差异，<strong>二进制内容</strong>存在显著区别。</p><ul><li>编译器通过名字修饰将函数名、参数类型/数量/顺序编码为唯一符号。C语言仅用函数名标识符号。</li><li>异常处理与运行时类型信息(RTTI)：编译器在二进制中插入异常处理框架​（如try/catch的栈回退逻辑）和RTTI数据结构​（用于dynamic_cast和typeid），以支持面向对象特性。C语言没有。</li><li>函数调用约定与对象模型：C++成员函数调用隐含传递this指针（通常通过寄存器或栈），而C函数无此机制。C++在main()前/后插入全局/静态对象的构造/析构代码，而C程序仅按代码顺序执行。</li></ul><h2 id="多继承把子类指针转为父类指针和单继承的区别在哪里？">多继承把子类指针转为父类指针和单继承的区别在哪里？</h2><p>多继承和单继承下子类指针向父类指针的转换存在本质区别，核心差异在于<strong>内存布局的复杂性和指针偏移机制</strong>。</p><ul><li>单继承：子类对象的内存布局为父类部分在前，子类新增部分在后。子类指针Derived<em>转换为父类指针Base</em>时，​地址不变。因父类部分位于对象起始位置，无需调整指针。子类与父类共享一个虚表指针，位于对象起始处。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> x; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-type">int</span> y; &#125;;<br></code></pre></td></tr></table></figure><ul><li>多继承：子类对象<strong>按继承顺序排列</strong>多个父类，​每个父类占据独立内存区域。转换到第一个父类​（如Base1*）时地址不变（与单继承相同）。转换到非第一个父类​（如Base2*）时，​编译器自动添加偏移量，指向Base2在子类中的起始位置。​每个含虚函数的父类在子类中<strong>独立维护虚表指针</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123; <span class="hljs-type">int</span> b; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123; <span class="hljs-type">int</span> c; &#125;;<br></code></pre></td></tr></table></figure><h2 id="有的类把析构函数声明为虚函数，什么场景下会用到？">有的类把析构函数声明为虚函数，什么场景下会用到？</h2><p>将析构函数声明为虚函数的核心目的是<strong>解决基类指针指向派生类对象时的资源正确释放问题</strong>，避免内存泄漏和未定义行为。</p><ul><li>多态基类（通过基类指针删除派生类对象）：当基类指针指向派生类对象，且基类析构函数非虚时，delete该指针仅调用基类析构函数，派生类的析构函数不被执行，导致派生类资源（如动态内存、文件句柄等）泄漏。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 释放派生类资源 */</span> &#125;<br>&#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 正确调用顺序：Derived::~Derived() → Base::~Base()</span><br></code></pre></td></tr></table></figure><ul><li>抽象类（含纯虚函数的接口类）:强制派生类实现析构逻辑，确保多态销毁安全。抽象类本身不可实例化，但需为纯虚析构函数提供定义（空实现即可）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractBase</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚析构</span><br>&#125;;<br>AbstractBase::~<span class="hljs-built_in">AbstractBase</span>() &#123;&#125;   <span class="hljs-comment">// 必须定义</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Impl</span> : <span class="hljs-keyword">public</span> AbstractBase &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Impl</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 资源释放 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>工厂模式返回基类指针:工厂函数返回基类指针（实际指向派生类对象），需通过基类指针统一管理对象生命周期</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Base* <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(); &#125;<br>&#125;;<br><br>Base* obj = Factory::<span class="hljs-built_in">createObject</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 依赖虚析构正确释放Derived资源</span><br></code></pre></td></tr></table></figure><ul><li>多层级继承结构：若中间层基类（非最顶层）可能被多态使用，其析构函数也需为虚函数，以确保析构链完整执行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>(); &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Middle</span>(); &#125;; <span class="hljs-comment">// 必须为虚</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Middle &#123; ~<span class="hljs-built_in">Derived</span>(); &#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 调用顺序：Derived → Middle → Base</span><br></code></pre></td></tr></table></figure><h2 id="unique指针在编译期如何保证是真的unique？">unique指针在编译期如何保证是真的unique？</h2><p>unique_ptr实现真的unique是靠的以下几个机制：</p><ul><li><strong>禁用拷贝语义</strong>(核心)：unique_ptr 内部将拷贝构造函数和拷贝赋值运算符声明为 = delete，直接禁止复制行为。</li><li>仅支持移动语义：unique_ptr 允许通过移动操作转移所有权，转移后原指针变为 nullptr。临时右值可隐式移动。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = std::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><ul><li>编译器的静态检查:类型系统强制约束,如当尝试拷贝时，编译器检查到调用了被删除的函数，直接报错。</li></ul><h2 id="移动语义如何使用？">移动语义如何使用？</h2><p>移动语义是C++11引入的核心特性，通过转移资源所有权而非复制资源，显著提升程序性能。绑定临时对象（右值），标记可被&quot;窃取&quot;资源的对象。使用move将左值强制转换为右值引用，触发移动语义。需定义移动构造函数和移动赋值运算符，并标记noexcept以保证异常安全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string s2 = std::<span class="hljs-built_in">move</span>(s1);  <span class="hljs-comment">// s1的资源被转移给s2，s1变为空</span><br></code></pre></td></tr></table></figure><h2 id="emplace-back和push-back的区别？">emplace_back和push_back的区别？</h2><p>两者均为容器尾部添加元素的方法，但<strong>底层机制</strong>和<strong>适用场景</strong>不同。</p><ul><li>push_back:先构造临时对象，再拷贝/移动到容器中.</li><li>emplace_back:​直接在容器内存中构造对象，避免临时对象创建和拷贝/移动。减少了构造临时对象这一步，性能更优。不支持初始化列表，存在隐式类型转换风险。<br>结论：emplace_back的效率相对更高，因此在代码中<strong>尽量用emplace_back</strong>代替push_back。</li></ul><h2 id="deque和vector的区别？内存布局有啥区别？">deque和vector的区别？内存布局有啥区别？</h2><ul><li>queue:​分段连续存储，由多个固定大小的内存块（chunks）组成，通过中控器（指针数组）管理逻辑连续性。动态分配新内存块，只需更新中控器的指针，​无需移动现有元素。扩容成本更低。无法保证整体内存连续。需高频头尾操作时使用queue。</li><li>vector:​单块连续内存，元素<strong>物理地址连续</strong>,容量不足时，重新分配一块更大的连续内存,严格连续，支持直接传递首地址。操作集中在尾部。</li></ul><h2 id="weak-ptr如何解决循环引用？">weak_ptr如何解决循环引用？</h2><p>weak_ptr 是 C++11 引入的智能指针，专为配合 shared_ptr 解决循环引用问题而设计，同时提供安全的对象访问机制。循环引用指两个或多个对象通过 shared_ptr 相互持有，导致引用计数无法归零，对象无法释放。<br>weak_ptr 通过​<strong>非拥有式观察</strong>打破循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    std::shared_ptr&lt;B&gt; b_ptr;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">/*出现循环引用*/</span><br>    <span class="hljs-comment">//std::shared_ptr&lt;A&gt; a_ptr;</span><br>    <span class="hljs-comment">/*修改为 weak_ptr解决循环引用*/</span><br>    std::weak_ptr&lt;A&gt; a_ptr;  <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="weak-ptr如何升级为shared-ptr？">weak_ptr如何升级为shared_ptr？</h2><p>weak_ptr 通过 lock() 方法安全升级为 shared_ptr，确保访问对象时其未被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::weak_ptr&lt;A&gt; weak_a = ...;  <span class="hljs-comment">// 从某处获取 weak_ptr</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> shared_a = weak_a.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// 尝试升级</span><br>    shared_a-&gt;<span class="hljs-built_in">do_something</span>();       <span class="hljs-comment">// 对象存活，安全访问</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 对象已销毁，避免悬垂指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>weak_ptr 通过控制块中的​弱引用计数​感知对象状态：<br>​构造时​：复制 shared_ptr 的控制块指针，弱引用计数 +1。<br>​析构时​：弱引用计数 -1，若弱引用计数和强引用计数均为 0，释放控制块。<br>​<strong>lock() 时</strong>​：检查控制块中的强引用计数，决定是否构造新 shared_ptr。</p><h2 id="C-的左值和右值是如何使用的？">C++的左值和右值是如何使用的？</h2><ul><li>左值：具有持久存储位置的对象，可被取地址（&amp;操作符），通常有变量名，可多次使用。可出现在赋值左侧，生命周期在作用域内有效。</li><li>右值：临时对象或字面量，无持久存储位置，不可取地址，通常为一次性使用的值。仅能出现在赋值右侧，生命周期在表达式结束时结束。</li></ul><h2 id="C-14的新特性？">C++14的新特性？</h2><p>C++14主要是对一些C++11的已有特性做了扩展。</p><ul><li>支持更灵活的类型推导，C++14支持decltype(auto),这个auto仅仅作为占位符使用。</li><li>constexpr支持更加广泛的语法和应用，如可以使用局部变量。</li><li>支持更加通用的lambda表达式，允许表达式内部使用auto参数，处理泛型类型更方便。</li><li>支持返回类型推导</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//推导出来是int类型的返回值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> num2=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num3=<span class="hljs-built_in">add</span>(num1,num2);<br>    cout&lt;&lt;num3;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-17的新特性？">C++17的新特性？</h2><ul><li>结构化绑定：允许通过一个简单的声明将元组或其他数据结构的成员绑定到变量。</li><li>if初始化：在 if 和 switch 语句中可以直接初始化变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num4 = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span> &lt; num4)<span class="hljs-comment">//C++17支持if初始化</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++17 yes&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ul><li>折叠表达式：支持更灵活的模板元编程</li><li>constexpr lambda 表达式：允许 lambda 表达式在编译时进行求值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个 constexpr lambda 表达式，用于计算两个整数的和</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-keyword">constexpr</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br><br>    <span class="hljs-comment">// 在编译时调用 lambda 表达式</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>std::optional：提供了一种可选值的容器，用于解决空指针的问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个可能返回无效值的函数，使用 optional 来安全地表示结果</span><br><span class="hljs-function">optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回无值状态</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> numerator / denominator;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> result1 = <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (result<span class="hljs-number">1.</span><span class="hljs-built_in">has_value</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Result of 10 / 2: &quot;</span> &lt;&lt; result<span class="hljs-number">1.</span><span class="hljs-built_in">value</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Division by zero error.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> result2 = <span class="hljs-built_in">divide</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 除以零，应该失败</span><br>    <span class="hljs-keyword">if</span> (result2)<br>    &#123;<br>        <span class="hljs-comment">// 另一种检查方式</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Result of 5 / 0: &quot;</span> &lt;&lt; *result2 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Division by zero error.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>std::variant：提供了一种可变的类型安全的联合。</li><li>filesystem：提供了一个现代化的、面向对象的文件系统操作 API。</li></ul><h2 id="如何让对象只能产生在堆上？">如何让对象只能产生在堆上？</h2><p>将对象的<strong>析构函数设置为私有</strong>的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。</p><h2 id="如何让对象只能产生在栈上？">如何让对象只能产生在栈上？</h2><p>把构造函数禁用，使其无法new对象在堆上。</p><h2 id="C-指针悬挂问题是什么，如何解决？">C++指针悬挂问题是什么，如何解决？</h2><p>指针悬挂是C++中因内存管理不当导致的常见问题，指指针指向的内存已被释放或失效，但指针仍保留原地址。访问此类指针会引发未定义行为​。以下是一些常见的场景和解决方法。</p><ul><li>指针释放后未置空：内存释放后，指针未置空，仍指向无效地址。解决方法是释放内存后立即置空指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*指针释放后未置空的场景*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 动态分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Before delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 释放内存</span><br>*p = <span class="hljs-number">30</span>; <span class="hljs-comment">// 未定义行为：使用已释放的内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;After delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 操作悬空指针</span><br><br><span class="hljs-comment">/*指针释放后立即置空指针的场景*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 动态分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Before delete: &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 释放内存</span><br>p=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将指针置空</span><br></code></pre></td></tr></table></figure><ul><li>返回局部变量地址：函数返回局部变量的指针，局部变量销毁后指针失效。解决方法是避免返回局部对象指针/引用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*返回局部变量地址的场景*/</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createDangling</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">return</span> &amp;x; <span class="hljs-comment">// 返回后x销毁，指针悬空</span><br>&#125;<br><span class="hljs-comment">/*返回动态分配内存或静态变量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createSafe</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 调用者需负责delete操作</span><br>&#125;    <br></code></pre></td></tr></table></figure><ul><li>容器内存重分配：容器扩容导致内存重新分配，原有元素指针失效。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*容器内存重分配的场景*/</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;vec[<span class="hljs-number">0</span>];<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 内存重分配，p悬空</span><br></code></pre></td></tr></table></figure><ul><li>多指针共享同一内存​：多个指针指向同一内存，其中一个释放内存后，其余指针未更新。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*多指针共享同一内存的场景*/</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span>* p2 = p1;<br><span class="hljs-keyword">delete</span> p1; <span class="hljs-comment">// p1和p2均悬空</span><br></code></pre></td></tr></table></figure><h2 id="C-中的特化和偏特化是什么？">C++中的特化和偏特化是什么？</h2><p>C++中的模板特化和偏特化是模板编程中用于针对特定类型或条件提供定制化实现的高级技术，旨在<strong>优化性能、处理特殊逻辑或增强类型安全性</strong>。</p><ul><li><p>模板特化(全特化)：为模板的所有参数指定具体类型，完全覆盖通用模板的实现。</p></li><li><p>模板偏特化：仅对模板的部分参数进行特化，其余参数保持泛型。</p></li></ul><pre><code class="language-c++">/*模板全特化和偏特化的例子*/#include &lt;iostream&gt;using namespace std;// 主模板template &lt;typename T&gt;class Vector &#123;private:    T* data;    size_t size;public:    Vector(size_t s) : size(s) &#123;        data = new T[size];    &#125;    ~Vector() &#123;        delete[] data;    &#125;    void info() &#123;        cout &lt;&lt; &quot;通用Vector&quot; &lt;&lt; endl;    &#125;&#125;;// 全特化：bool 类型template &lt;&gt;class Vector&lt;bool&gt; &#123;private:    unsigned char* compressedData; // 使用位压缩存储 bool 数组public:    Vector(size_t size) &#123;        compressedData = new unsigned char[(size + 7) / 8];    &#125;    ~Vector() &#123;        delete[] compressedData;    &#125;    void info() &#123;        cout &lt;&lt; &quot;特化BoolVector&quot; &lt;&lt; endl;    &#125;&#125;;// 偏特化：所有指针类型的 Vector&lt;T*&gt;template &lt;typename T&gt;class Vector&lt;T*&gt; &#123;private:    T** data;    size_t size;public:    Vector(size_t s) : size(s) &#123;        data = new T*[size];    &#125;    ~Vector() &#123;        delete[] data;    &#125;    void info() &#123;        cout &lt;&lt; &quot;偏特化PointerVector&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Vector&lt;int&gt; v1(10);       // 调用主模板    v1.info();                // 输出: 通用Vector    Vector&lt;bool&gt; v2(10);      // 调用全特化    v2.info();                // 输出: 特化BoolVector    Vector&lt;int*&gt; v3(10);      // 调用偏特化    v3.info();                // 输出: 偏特化PointerVector    return 0;&#125;// 定义一个支持显式构造的类class MyClass&#123;public:    // 使用 explicit 防止隐式转换    explicit MyClass(int value) : data(value)    &#123;        std::cout &lt;&lt; &quot;Explicit constructor called with value: &quot; &lt;&lt; data &lt;&lt; std::endl;    &#125;    void printData() const    &#123;        std::cout &lt;&lt; &quot;Data: &quot; &lt;&lt; data &lt;&lt; std::endl;    &#125;private:    int data;&#125;;// 演示没有 explicit 的情况class MyOtherClass&#123;public:    MyOtherClass(int value) : data(value)    &#123;        std::cout &lt;&lt; &quot;Non-explicit constructor called with value: &quot; &lt;&lt; data &lt;&lt; std::endl;    &#125;    void printData() const    &#123;        std::cout &lt;&lt; &quot;MyOtherClass Data: &quot; &lt;&lt; data &lt;&lt; std::endl;    &#125;private:    int data;&#125;;int main()&#123;    // 显式调用 MyClass 构造函数（必须的，因为构造函数被声明为 explicit）    MyClass obj1(10);    obj1.printData();    // 下面这行会编译失败，因为 explicit 禁止了隐式转换    // MyClass obj2 = 20;    // 正确写法：显式调用构造函数    MyClass obj2 = MyClass(20);    obj2.printData();    // 对于没有 explicit 的类，允许隐式转换    MyOtherClass obj3 = 30; // 隐式转换合法    obj3.printData();    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络八股文</title>
    <link href="/2025/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2025/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1>计算机网络八股文</h1><h2 id="TCP三次握手和四次挥手，为什么这么设计？">TCP三次握手和四次挥手，为什么这么设计？</h2><ul><li>三次握手：在建立TCP连接时，cilent客户端向server服务器端发送一个SYN（同步）标志的数据包，服务器端收到后回复一个SYN和ACK（确认）标志的数据包，表示接收到了客户端的请求，并同意建立连接，最后客户端再发送一个ACK标志的数据包，表示连接已经建立。这样就完成了三次握手，建立了连接。</li><li>四次挥手：在终止TCP连接时，一方（假设是客户端）向另一方（服务器端）发送一个FIN（结束）标志的数据包，表示要关闭连接，另一方收到后会回复一个ACK标志的数据包，表示收到了关闭请求。然后另一方再发送一个FIN标志的数据包给第一方，表示同意关闭连接，最后第一方再发送一个ACK标志的数据包，表示接收到了对方的关闭请求。这样就完成了四次挥手，终止了连接。</li></ul><h2 id="TCP出现三次挥手是什么情况，会有什么影响？">TCP出现三次挥手是什么情况，会有什么影响？</h2><p>当第四次挥手（Client的ACK）丢失或Server未收到ACK时，会出现三次挥手的情况。<br>三次挥手的影响：</p><ul><li>Server端资源泄露,最终导致端口耗尽，无法提供服务。</li><li>后续连接异常</li><li>数据传输错误</li></ul><h2 id="TCP三次握手的原因是什么？">TCP三次握手的原因是什么？</h2><p>TCP三次握手是<strong>建立可靠网络连接</strong>的核心机制。原因有三个：</p><ul><li><strong>防止历史连接初始化</strong>(核心原因)</li><li>同步双方初始序列号：为数据包提供有序标识，解决乱序、重复、丢包问题</li><li>避免资源浪费</li></ul><h2 id="OSI模型下每层常见的协议有哪些？">OSI模型下每层常见的协议有哪些？</h2><p>具体内容会在协议八股文内介绍，此外会有详细的协议的介绍。如果时间充足的话。<br>应用层：<strong>HTTP/HTTPS</strong>，<strong>DHCP</strong><br>表示层：<strong>TLS/SSL</strong><br>会话层：RPC，SSH<br>传输层：<strong>TCP,UDP</strong><br>网络层：IP,ICMP,<strong>OSPF/BGP</strong>,<strong>ARP</strong>，<strong>IPsec</strong><br>数据链路层：Ethernet,WiFi，VLAN，HDLC<br>物理层：IEEE 802.3</p><h2 id="TCP的拥塞控制算法有哪些，请你详细介绍这些算法？">TCP的拥塞控制算法有哪些，请你详细介绍这些算法？</h2><p>TCP的拥塞控制算法从远到近主要有：慢启动，拥塞避免，快重传，快恢复，CUBIC​算法，BIC算法，Vegas​算法，Veno​算法，BBR算法</p><ul><li>慢启动：初始阶段以指数级增长探测网络容量，避免突发流量冲击。指数增长易导致突发丢包，尤其在高带宽网络中。</li><li>拥塞避免：线性增长cwnd，避免过度占用带宽。平衡网络负载，避免拥塞恶化。</li><li>快重传：通过重复ACK快速检测丢包，避免等待超时。连续收到3个重复ACK就会触发。</li><li>快恢复：避免因单个丢包直接回到慢启动，维持较高传输效率。</li><li>CUBIC算法：使用三次函数替代线性增长，高带宽网络中更平稳，<strong>Linux默认算法</strong>。</li><li>BIC算法：二分搜索寻找最大可用带宽，通过增/减窗口逼近平衡点。适用于<strong>长距离高速网络</strong>。</li><li>Vegas​算法：通过RTT变化预测拥塞。若实际吞吐量低于预期，减小cwnd。与基于丢包的算法竞争时处于劣势。</li><li>Veno​算法：丢包事件 → 触发快重传 → cwnd减半 → 进入快恢复 → 收到新ACK后退出恢复。结合丢包和延迟信号，区分无线丢包与真实拥塞丢包。适用于<strong>无线网络</strong></li><li>BBR算法：基于带宽和延迟估计，主动避免缓冲区膨胀</li></ul><h2 id="ARP-欺骗是什么，如何防范？">ARP 欺骗是什么，如何防范？</h2><p>ARP欺骗是一种网络攻击手段，通过伪造IP-MAC映射关系，导致数据被劫持或网络中断，在界面上的表现为本来通信的双方通信时断时续。这个问题可以从三个角度来回答：</p><ul><li>网络设备层防御：开启ARP表项固化，学习到合法的ARP表项之后，将其绑定到端口，后续ARP表项将不再更新直到ARP表项手动使其失效。或者使用ARP严格学习，如果是固定设备的话使用该方法每次去校验ARP表项的接口和VLAN信息等，或者在更新ARP表项前发送ACK请求，确认ARP表项的变更。打开ARP报文的深度检查检查以太帧头部和ARP报文内容是否匹配。也可以使用安全协议如IPSEC去防御，IPSEC会将内外网IP分开，在通信双方间建立安全隧道保证通信的安全可靠。</li><li>网络架构优化：划分VLAN缩小广播域，PPPoE认证替代ARP(很挫的一种方法)，交换机端口安全绑定</li><li>终端防护措施：静态ARP绑定，安装ARP防火墙</li></ul><h2 id="什么是ICMP协议">什么是ICMP协议?</h2><p>ICMP是TCP/IP协议族中网络层的协议，主要用于传输网络层控制消息的协议来达到<strong>对网络信息进行诊断</strong>，以及<strong>发送错误报告</strong>的目的。<br>⽐如ping 和traceroute就是通过icmp来对评估⽹络连接质量以及揭示数据包在⽹络的传输路径的来达到网络信息诊断的目的的。比如当数据包⽆法到达目的地时，路由器或目标主机就会发送目的地不可达消息，有助于识别网络问题，通过这种方式来达到发送错误报告的目的。<br>举个例子，我要和同事的一台电脑进行通信。我会首先ping一下他的电脑，首次ping肯定是失败的，由于没有学到ARP表项，会通过ARP协议进行学习，将同事的IP地址和MAC地址的映射到本地的网络层，有一个ARP表存储的ARP表项，然后我就可以知道IP和对应的MAC地址，后续的PING出去的ICMP报文就可以顺利到达同事，成功通信。目前的ICMP分为ICMP4和ICMP6，对应IP协议的V4和V6版本。</p><h2 id="如何解决TCP的粘包">如何解决TCP的粘包?</h2><p>解决TCP的粘包问题有以下几个方法：</p><ul><li>添加消息边界：在发送数据时，给数据包添加⼀个特殊的边界标识，比如换行符或特殊字符。接收方在接收数据时，根据数据标识堆数据包进行拆分。</li><li>使用定长消息：约定每个数据包的长度固定。如果数据长度不足，那么就用特定字符去填写。这个方法适合于数据包长度固定的场景，但是可能会导致数据传输的效率降低。(比较挫，一般其他的协议也不会使用这种办法)</li><li>添加消息头：在发送数据的时候，为数据包添加⼀个消息头，在消息头中包含数据包的长信息。(有点类似蓝牙的协议，蓝牙协议就是这么做的)接收⽅在接收数据时，先解析消息头，获取数据包长度，然后根据长度对数据包进行拆分。4</li><li>使⽤应⽤层协议：使⽤HTTP或者FTP等协议，这些协议都已经解决了粘包问题。</li></ul><h2 id="TCP挥⼿过程中，为什么需要存在time-wait状态？">TCP挥⼿过程中，为什么需要存在time_wait状态？</h2><p><img src="image-1.png" alt="TCP全程状态图"></p><ul><li><strong>防⽌错误接收历史报⽂</strong>：如果立刻断开连接，那么有可能断开连接后，立刻复用了原来的ip地址和端口号进⾏了重新连接，上⼀次连接过程中发送的无效报⽂可能会在新的连接中到达，这时新的连接无法辨别出这个报⽂是上⼀次连接发送的报文，就可能会发⽣错误。</li><li>保证双⽅可以正常关闭：如果在客户端发送给服务端的ACK的报⽂丢失了，服务端会给客户端重传⼀个FIN,这个时间最长是2MSL， 客户端需要等待2MSL，判断在这个时间是否收到了服务端的重传的FIN的报⽂，如果收到了，客户端也要重传ACK报⽂，来保证双⽅正常关闭。</li></ul><h2 id="如何解决大量TIME-WAIT-状态的问题">如何解决大量TIME_WAIT 状态的问题?</h2><ul><li>调整 MSL：减⼩最⼤报⽂段⽣存时间（MSL）的值，以减少TIME_WAIT状态的持续时 间。这样可以更快地释放 TIME_WAIT 状态的连接资源，但请注意，设置太⼩的MSL 值可能导致⽹络问题，如旧连接的数据包⼲扰新连接。</li><li>使⽤连接池：在客户端和服务器之间使⽤连接池，以便复⽤已经建⽴的TCP连接，⽽不是频繁地创建和关闭新连接。这可以显著减少TIME_WAIT状态的数量，同时提⾼应⽤程序的性能。</li><li>使⽤ SO_REUSEADDR 套接字选项：在某些情况下，可以在服务器端启⽤SO_REUSEADDR 套接字选项。这允许服务器在TIME_WAIT状态的连接上重新绑定和监听端口。但请注意，这种方法可能会导致新旧连接之间的数据包混淆，因此需要谨慎使用．</li><li>使⽤ SO_LINGER 套接字选项：在某些情况下，可以在客户端启⽤SO_LINGER套接字选项，并将延迟时间设置为0。这将导致客户端在关闭连接时⽴即发送RST（复位）信号，⽽不是正常的四次挥⼿过程。这样可以避免 TIME_WAIT 状态，但可能导致数据丢失，因此需要谨慎使⽤。</li><li>优化应用程序逻辑：根据应用程序的需求，优化客户端和服务器之间的通信逻辑，以减少不必要的连接创建和关闭。例如，可以使用长连接（keep-alive）或WebSocket 等技术来保持连接，减少 TIME_WAIT 状态的数量。</li></ul><h2 id="https是如何进行加密的？">https是如何进行加密的？</h2><p>HTTPS 的加密机制是通过 ​SSL/TLS 协议实现的，结合了对称加密、非对称加密、数字证书和密钥交换技术，确保数据在传输过程中的机密性、完整性和身份真实性。<br>流程：<br>TCP 连接建立-&gt;TLS 握手协商(​Client Hello,Server Hello,​证书验证,密钥交换,生成会话密钥)-&gt;加密数据传输</p><h2 id="讲⼀下红⿊树的特性以及它和⼆插搜索树的区别">讲⼀下红⿊树的特性以及它和⼆插搜索树的区别?</h2><ul><li>⼆叉搜索树是⼀种特殊的⼆叉树，其中每个节点都有⼀个与之关联的键，且对于树中的所有节点，左⼦树中的所有键都小于节点的键，右⼦树中的所有键都⼤于节点的键。这使得⼆叉搜索树可以⾼效地执⾏查找、插⼊和删除操作。</li><li>红⿊树是⼀种自平衡的⼆叉搜索树，它在⼆叉搜索树的基础上<strong>增加了⼀些额外的性质</strong>。红⿊树的每个节点都有⼀个颜色属性，可以是红⾊或⿊⾊。并且节点的颜⾊之间存在⼀些特定规则。</li></ul><h2 id="为什么用epoll来实现IO复用？">为什么用epoll来实现IO复用？</h2><ul><li>高性能： epoll 在处理大量连接时具有较高的性能，能够有效地处理大规模的并发连接，因为它采用了事件驱动的方式，只在有事件发生时才唤醒相应的线程或进程，减少了系统调用的开销。</li><li>支持更多的并发连接： epoll 支持水平触发（LT）和边缘触发（ET）两种工作模式，可以更灵活地适应不同的应用场景，并且能够处理更多的并发连接。</li><li>支持跨平台： epoll 是 Linux 独有的系统调用，但是它的设计思想被其他操作系统所借鉴和实现，比如 FreeBSD 的 kqueue，因此可以在不同的操作系统上实现类似的功能。</li><li>更好的扩展性： epoll 提供了更加灵活的 API 接口，可以实现更复杂的事件处理逻辑，支持同时监控多种类型的文件描述符，包括套接字、管道、文件等。- 更好的内核支持： 随着 Linux 内核的不断升级，epoll 的性能和稳定性也在不断改善，因此成为了很多服务器开发人员的首选。</li></ul><h2 id="http的keep-alive是如何实现吗？">http的keep-alive是如何实现吗？</h2><p>HTTP 的 Keep-Alive 是通过在 HTTP 请求头中增加一个参数来实现的，这个参数是Connection: keep-alive。当客户端和服务器之间的通信使用了Keep-Alive 参数时，它指示服务器在发送完响应后保持 TCP 连接打开状态，以便后续的请求可以继续复用这个连接，而不必每次都重新建立连接。</p><h2 id="大端序和小端序是什么？">大端序和小端序是什么？</h2><p>大端序和小端序是计算机中数据在内存中存储的两种<strong>字节顺序</strong>。其核心区别在于高位字节与低位字节在内存地址中的<strong>存放顺序</strong>。</p><ul><li>大端序：数据的高位字节（最左侧字节）存储在低地址，低位字节（最右侧字节）存储在高地址。网络传输就是采用的大端序。</li><li>小端序：数据的低位字节存储在低地址，高位字节存储在高地址。</li></ul><h2 id="同一子网内的两台设备的通信过程是怎样的？">同一子网内的两台设备的通信过程是怎样的？</h2><p>以主机A需要给主机B发送消息为例。</p><ul><li><strong>ARP缓存检查</strong>：主机A查看自己的ARP缓存，检查是否有主机B的IP到MAC的映射。</li><li><strong>ARP请求</strong>：如果A没有B的MAC地址，就会在广播发送一个ARP请求，B接收到了以后会响应这个请求，A收到后就会更新B的MAC地址。</li><li><strong>构造报文</strong>：如果有映射，主机A构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为主机B的MAC，源MAC为主机A的MAC。</li><li><strong>MAC地址学习</strong>：主机A将报文发送给交换机，交换机进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来。</li><li><strong>MAC转发表检查</strong>：交换机C查看自己的MAC转发表，检查是否有主机B的MAC地址对应的端口号。如果有将报文从此端口转发出去，报文到达主机B。</li><li><strong>ARP请求</strong>：如果交换机C没有主机B的MAC转发表映射，采用洪泛的形式广播报文，主机B收到报文后向主机A回复，交换机C进行MAC表学习，将主机B的MAC对应的端口号记录下来。</li></ul><h2 id="不同网内的两台设备的通信过程是怎样的？">不同网内的两台设备的通信过程是怎样的？</h2><ul><li><strong>ARP缓存检查</strong>：主机A查看自己的ARP缓存，检查是否有路由器的IP到MAC的映射。</li><li><strong>ARP请求</strong>：如果主机A没有路由器的MAC地址，就会发送一个ARP请求广播，路由器接收到后会响应这个请求，主机A收到后更新路由器的MAC地址。</li><li><strong>构造报文</strong>：主机A构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为路由器的MAC，源MAC为主机A的MAC。</li><li><strong>MAC地址学习</strong>：主机A将报文发送给交换机，交换机进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来。</li><li><strong>MAC转发表检查</strong>：交换机查看自己的MAC转发表，检查是否有路由器的MAC到端口的映射。如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达路由器。</li><li><strong>路由器处理</strong>：路由器收到报文后，剥离报文的MAC帧头，查询路由表，发现目标主机B所在的网络是直连的，查看自己的ARP缓存表，如果有主机B的IP到MAC的映射关系，获取主机B的MAC，封装报文MAC帧头，目的MAC为主机B的MAC，源MAC为路由器的MAC，将报文通过交换机发往主机B。</li><li><strong>ARP请求</strong>：如果路由器没有主机B的MAC地址映射，路由器会发送ARP请求广播，主机B接收到后会响应这个请求，路由器收到后更新主机B的MAC地址。</li><li><strong>报文转发</strong>：路由器将报文发送给交换机，交换机进行MAC地址表学习，将主机B的MAC和报文端口号记录下来，交换机查看自己的MAC转发表，检查是否有主机B的MAC到端口的映射。如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达主机B。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
